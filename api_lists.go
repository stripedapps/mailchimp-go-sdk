/*
Mailchimp Marketing API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.0.55
Contact: apihelp@mailchimp.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ListsAPIService ListsAPI service
type ListsAPIService service

type ApiDeleteListsIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
}

func (r ApiDeleteListsIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdExecute(r)
}

/*
DeleteListsId Delete list

Delete a list from your Mailchimp account. If you delete a list, you'll lose the list history—including subscriber activity, unsubscribes, complaints, and bounces. You’ll also lose subscribers’ email addresses, unless you exported and backed up your list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiDeleteListsIdRequest
*/
func (a *ListsAPIService) DeleteListsId(ctx context.Context, listId string) ApiDeleteListsIdRequest {
	return ApiDeleteListsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdExecute(r ApiDeleteListsIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteListsIdInterestCategoriesIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	interestCategoryId string
}

func (r ApiDeleteListsIdInterestCategoriesIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdInterestCategoriesIdExecute(r)
}

/*
DeleteListsIdInterestCategoriesId Delete interest category

Delete a specific interest category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param interestCategoryId The unique ID for the interest category.
 @return ApiDeleteListsIdInterestCategoriesIdRequest
*/
func (a *ListsAPIService) DeleteListsIdInterestCategoriesId(ctx context.Context, listId string, interestCategoryId string) ApiDeleteListsIdInterestCategoriesIdRequest {
	return ApiDeleteListsIdInterestCategoriesIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		interestCategoryId: interestCategoryId,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdInterestCategoriesIdExecute(r ApiDeleteListsIdInterestCategoriesIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsIdInterestCategoriesId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories/{interest_category_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_category_id"+"}", url.PathEscape(parameterValueToString(r.interestCategoryId, "interestCategoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteListsIdInterestCategoriesIdInterestsIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	interestCategoryId string
	interestId string
}

func (r ApiDeleteListsIdInterestCategoriesIdInterestsIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdInterestCategoriesIdInterestsIdExecute(r)
}

/*
DeleteListsIdInterestCategoriesIdInterestsId Delete interest in category

Delete interests or group names in a specific category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param interestCategoryId The unique ID for the interest category.
 @param interestId The specific interest or 'group name'.
 @return ApiDeleteListsIdInterestCategoriesIdInterestsIdRequest
*/
func (a *ListsAPIService) DeleteListsIdInterestCategoriesIdInterestsId(ctx context.Context, listId string, interestCategoryId string, interestId string) ApiDeleteListsIdInterestCategoriesIdInterestsIdRequest {
	return ApiDeleteListsIdInterestCategoriesIdInterestsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		interestCategoryId: interestCategoryId,
		interestId: interestId,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdInterestCategoriesIdInterestsIdExecute(r ApiDeleteListsIdInterestCategoriesIdInterestsIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsIdInterestCategoriesIdInterestsId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories/{interest_category_id}/interests/{interest_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_category_id"+"}", url.PathEscape(parameterValueToString(r.interestCategoryId, "interestCategoryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_id"+"}", url.PathEscape(parameterValueToString(r.interestId, "interestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteListsIdMembersIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	subscriberHash string
}

func (r ApiDeleteListsIdMembersIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdMembersIdExecute(r)
}

/*
DeleteListsIdMembersId Archive list member

Archive a list member. To permanently delete, use the delete-permanent action.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ApiDeleteListsIdMembersIdRequest
*/
func (a *ListsAPIService) DeleteListsIdMembersId(ctx context.Context, listId string, subscriberHash string) ApiDeleteListsIdMembersIdRequest {
	return ApiDeleteListsIdMembersIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdMembersIdExecute(r ApiDeleteListsIdMembersIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsIdMembersId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteListsIdMembersIdNotesIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	subscriberHash string
	noteId string
}

func (r ApiDeleteListsIdMembersIdNotesIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdMembersIdNotesIdExecute(r)
}

/*
DeleteListsIdMembersIdNotesId Delete note

Delete a specific note for a specific list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @param noteId The id for the note.
 @return ApiDeleteListsIdMembersIdNotesIdRequest
*/
func (a *ListsAPIService) DeleteListsIdMembersIdNotesId(ctx context.Context, listId string, subscriberHash string, noteId string) ApiDeleteListsIdMembersIdNotesIdRequest {
	return ApiDeleteListsIdMembersIdNotesIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
		noteId: noteId,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdMembersIdNotesIdExecute(r ApiDeleteListsIdMembersIdNotesIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsIdMembersIdNotesId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/notes/{note_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"note_id"+"}", url.PathEscape(parameterValueToString(r.noteId, "noteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteListsIdMergeFieldsIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	mergeId string
}

func (r ApiDeleteListsIdMergeFieldsIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdMergeFieldsIdExecute(r)
}

/*
DeleteListsIdMergeFieldsId Delete merge field

Delete a specific merge field.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param mergeId The id for the merge field.
 @return ApiDeleteListsIdMergeFieldsIdRequest
*/
func (a *ListsAPIService) DeleteListsIdMergeFieldsId(ctx context.Context, listId string, mergeId string) ApiDeleteListsIdMergeFieldsIdRequest {
	return ApiDeleteListsIdMergeFieldsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		mergeId: mergeId,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdMergeFieldsIdExecute(r ApiDeleteListsIdMergeFieldsIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsIdMergeFieldsId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/merge-fields/{merge_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_id"+"}", url.PathEscape(parameterValueToString(r.mergeId, "mergeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteListsIdSegmentsIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	segmentId string
}

func (r ApiDeleteListsIdSegmentsIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdSegmentsIdExecute(r)
}

/*
DeleteListsIdSegmentsId Delete segment

Delete a specific segment in a list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param segmentId The unique id for the segment.
 @return ApiDeleteListsIdSegmentsIdRequest
*/
func (a *ListsAPIService) DeleteListsIdSegmentsId(ctx context.Context, listId string, segmentId string) ApiDeleteListsIdSegmentsIdRequest {
	return ApiDeleteListsIdSegmentsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		segmentId: segmentId,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdSegmentsIdExecute(r ApiDeleteListsIdSegmentsIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsIdSegmentsId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments/{segment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segment_id"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteListsIdSegmentsIdMembersIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	segmentId string
	subscriberHash string
}

func (r ApiDeleteListsIdSegmentsIdMembersIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdSegmentsIdMembersIdExecute(r)
}

/*
DeleteListsIdSegmentsIdMembersId Remove list member from segment

Remove a member from the specified static segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param segmentId The unique id for the segment.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
 @return ApiDeleteListsIdSegmentsIdMembersIdRequest
*/
func (a *ListsAPIService) DeleteListsIdSegmentsIdMembersId(ctx context.Context, listId string, segmentId string, subscriberHash string) ApiDeleteListsIdSegmentsIdMembersIdRequest {
	return ApiDeleteListsIdSegmentsIdMembersIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		segmentId: segmentId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdSegmentsIdMembersIdExecute(r ApiDeleteListsIdSegmentsIdMembersIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsIdSegmentsIdMembersId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments/{segment_id}/members/{subscriber_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segment_id"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteListsIdWebhooksIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	webhookId string
}

func (r ApiDeleteListsIdWebhooksIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdWebhooksIdExecute(r)
}

/*
DeleteListsIdWebhooksId Delete webhook

Delete a specific webhook in a list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param webhookId The webhook's id.
 @return ApiDeleteListsIdWebhooksIdRequest
*/
func (a *ListsAPIService) DeleteListsIdWebhooksId(ctx context.Context, listId string, webhookId string) ApiDeleteListsIdWebhooksIdRequest {
	return ApiDeleteListsIdWebhooksIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		webhookId: webhookId,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdWebhooksIdExecute(r ApiDeleteListsIdWebhooksIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsIdWebhooksId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/webhooks/{webhook_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"webhook_id"+"}", url.PathEscape(parameterValueToString(r.webhookId, "webhookId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetListMemberTagsRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	subscriberHash string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListMemberTagsRequest) Fields(fields []string) ApiGetListMemberTagsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListMemberTagsRequest) ExcludeFields(excludeFields []string) ApiGetListMemberTagsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetListMemberTagsRequest) Count(count int32) ApiGetListMemberTagsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetListMemberTagsRequest) Offset(offset int32) ApiGetListMemberTagsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetListMemberTagsRequest) Execute() (*CollectionOfTags, *http.Response, error) {
	return r.ApiService.GetListMemberTagsExecute(r)
}

/*
GetListMemberTags List member tags

Get the tags on a list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ApiGetListMemberTagsRequest
*/
func (a *ListsAPIService) GetListMemberTags(ctx context.Context, listId string, subscriberHash string) ApiGetListMemberTagsRequest {
	return ApiGetListMemberTagsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return CollectionOfTags
func (a *ListsAPIService) GetListMemberTagsExecute(r ApiGetListMemberTagsRequest) (*CollectionOfTags, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionOfTags
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListMemberTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	beforeDateCreated *string
	sinceDateCreated *string
	beforeCampaignLastSent *string
	sinceCampaignLastSent *string
	email *string
	sortField *string
	sortDir *string
	hasEcommerceStore *bool
	includeTotalContacts *bool
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsRequest) Fields(fields []string) ApiGetListsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsRequest) ExcludeFields(excludeFields []string) ApiGetListsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetListsRequest) Count(count int32) ApiGetListsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetListsRequest) Offset(offset int32) ApiGetListsRequest {
	r.offset = &offset
	return r
}

// Restrict response to lists created before the set date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiGetListsRequest) BeforeDateCreated(beforeDateCreated string) ApiGetListsRequest {
	r.beforeDateCreated = &beforeDateCreated
	return r
}

// Restrict results to lists created after the set date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiGetListsRequest) SinceDateCreated(sinceDateCreated string) ApiGetListsRequest {
	r.sinceDateCreated = &sinceDateCreated
	return r
}

// Restrict results to lists created before the last campaign send date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiGetListsRequest) BeforeCampaignLastSent(beforeCampaignLastSent string) ApiGetListsRequest {
	r.beforeCampaignLastSent = &beforeCampaignLastSent
	return r
}

// Restrict results to lists created after the last campaign send date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiGetListsRequest) SinceCampaignLastSent(sinceCampaignLastSent string) ApiGetListsRequest {
	r.sinceCampaignLastSent = &sinceCampaignLastSent
	return r
}

// Restrict results to lists that include a specific subscriber&#39;s email address.
func (r ApiGetListsRequest) Email(email string) ApiGetListsRequest {
	r.email = &email
	return r
}

// Returns files sorted by the specified field.
func (r ApiGetListsRequest) SortField(sortField string) ApiGetListsRequest {
	r.sortField = &sortField
	return r
}

// Determines the order direction for sorted results.
func (r ApiGetListsRequest) SortDir(sortDir string) ApiGetListsRequest {
	r.sortDir = &sortDir
	return r
}

// Restrict results to lists that contain an active, connected, undeleted ecommerce store.
func (r ApiGetListsRequest) HasEcommerceStore(hasEcommerceStore bool) ApiGetListsRequest {
	r.hasEcommerceStore = &hasEcommerceStore
	return r
}

// Return the total_contacts field in the stats response, which contains an approximate count of all contacts in any state.
func (r ApiGetListsRequest) IncludeTotalContacts(includeTotalContacts bool) ApiGetListsRequest {
	r.includeTotalContacts = &includeTotalContacts
	return r
}

func (r ApiGetListsRequest) Execute() (*SubscriberLists, *http.Response, error) {
	return r.ApiService.GetListsExecute(r)
}

/*
GetLists Get lists info

Get information about all lists in the account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetListsRequest
*/
func (a *ListsAPIService) GetLists(ctx context.Context) ApiGetListsRequest {
	return ApiGetListsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubscriberLists
func (a *ListsAPIService) GetListsExecute(r ApiGetListsRequest) (*SubscriberLists, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriberLists
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetLists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.beforeDateCreated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_date_created", r.beforeDateCreated, "")
	}
	if r.sinceDateCreated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_date_created", r.sinceDateCreated, "")
	}
	if r.beforeCampaignLastSent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_campaign_last_sent", r.beforeCampaignLastSent, "")
	}
	if r.sinceCampaignLastSent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_campaign_last_sent", r.sinceCampaignLastSent, "")
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
	}
	if r.sortDir != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_dir", r.sortDir, "")
	}
	if r.hasEcommerceStore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_ecommerce_store", r.hasEcommerceStore, "")
	}
	if r.includeTotalContacts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_total_contacts", r.includeTotalContacts, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	fields *[]string
	excludeFields *[]string
	includeTotalContacts *bool
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdRequest) Fields(fields []string) ApiGetListsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdRequest) ExcludeFields(excludeFields []string) ApiGetListsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

// Return the total_contacts field in the stats response, which contains an approximate count of all contacts in any state.
func (r ApiGetListsIdRequest) IncludeTotalContacts(includeTotalContacts bool) ApiGetListsIdRequest {
	r.includeTotalContacts = &includeTotalContacts
	return r
}

func (r ApiGetListsIdRequest) Execute() (*SubscriberList, *http.Response, error) {
	return r.ApiService.GetListsIdExecute(r)
}

/*
GetListsId Get list info

Get information about a specific list in your Mailchimp account. Results include list members who have signed up but haven't confirmed their subscription yet and unsubscribed or cleaned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiGetListsIdRequest
*/
func (a *ListsAPIService) GetListsId(ctx context.Context, listId string) ApiGetListsIdRequest {
	return ApiGetListsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return SubscriberList
func (a *ListsAPIService) GetListsIdExecute(r ApiGetListsIdRequest) (*SubscriberList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriberList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.includeTotalContacts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_total_contacts", r.includeTotalContacts, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdAbuseReportsRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdAbuseReportsRequest) Fields(fields []string) ApiGetListsIdAbuseReportsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdAbuseReportsRequest) ExcludeFields(excludeFields []string) ApiGetListsIdAbuseReportsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetListsIdAbuseReportsRequest) Count(count int32) ApiGetListsIdAbuseReportsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetListsIdAbuseReportsRequest) Offset(offset int32) ApiGetListsIdAbuseReportsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetListsIdAbuseReportsRequest) Execute() (*AbuseComplaints, *http.Response, error) {
	return r.ApiService.GetListsIdAbuseReportsExecute(r)
}

/*
GetListsIdAbuseReports List abuse reports

Get all abuse reports for a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiGetListsIdAbuseReportsRequest
*/
func (a *ListsAPIService) GetListsIdAbuseReports(ctx context.Context, listId string) ApiGetListsIdAbuseReportsRequest {
	return ApiGetListsIdAbuseReportsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return AbuseComplaints
func (a *ListsAPIService) GetListsIdAbuseReportsExecute(r ApiGetListsIdAbuseReportsRequest) (*AbuseComplaints, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AbuseComplaints
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdAbuseReports")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/abuse-reports"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdAbuseReportsIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	reportId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdAbuseReportsIdRequest) Fields(fields []string) ApiGetListsIdAbuseReportsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdAbuseReportsIdRequest) ExcludeFields(excludeFields []string) ApiGetListsIdAbuseReportsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetListsIdAbuseReportsIdRequest) Count(count int32) ApiGetListsIdAbuseReportsIdRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetListsIdAbuseReportsIdRequest) Offset(offset int32) ApiGetListsIdAbuseReportsIdRequest {
	r.offset = &offset
	return r
}

func (r ApiGetListsIdAbuseReportsIdRequest) Execute() (*AbuseComplaint, *http.Response, error) {
	return r.ApiService.GetListsIdAbuseReportsIdExecute(r)
}

/*
GetListsIdAbuseReportsId Get abuse report

Get details about a specific abuse report.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param reportId The id for the abuse report.
 @return ApiGetListsIdAbuseReportsIdRequest
*/
func (a *ListsAPIService) GetListsIdAbuseReportsId(ctx context.Context, listId string, reportId string) ApiGetListsIdAbuseReportsIdRequest {
	return ApiGetListsIdAbuseReportsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		reportId: reportId,
	}
}

// Execute executes the request
//  @return AbuseComplaint
func (a *ListsAPIService) GetListsIdAbuseReportsIdExecute(r ApiGetListsIdAbuseReportsIdRequest) (*AbuseComplaint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AbuseComplaint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdAbuseReportsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/abuse-reports/{report_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"report_id"+"}", url.PathEscape(parameterValueToString(r.reportId, "reportId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdActivityRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	count *int32
	offset *int32
	fields *[]string
	excludeFields *[]string
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetListsIdActivityRequest) Count(count int32) ApiGetListsIdActivityRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetListsIdActivityRequest) Offset(offset int32) ApiGetListsIdActivityRequest {
	r.offset = &offset
	return r
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdActivityRequest) Fields(fields []string) ApiGetListsIdActivityRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdActivityRequest) ExcludeFields(excludeFields []string) ApiGetListsIdActivityRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetListsIdActivityRequest) Execute() (*ListActivity, *http.Response, error) {
	return r.ApiService.GetListsIdActivityExecute(r)
}

/*
GetListsIdActivity List recent activity

Get up to the previous 180 days of daily detailed aggregated activity stats for a list, not including Automation activity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiGetListsIdActivityRequest
*/
func (a *ListsAPIService) GetListsIdActivity(ctx context.Context, listId string) ApiGetListsIdActivityRequest {
	return ApiGetListsIdActivityRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return ListActivity
func (a *ListsAPIService) GetListsIdActivityExecute(r ApiGetListsIdActivityRequest) (*ListActivity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListActivity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdActivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/activity"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdClientsRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdClientsRequest) Fields(fields []string) ApiGetListsIdClientsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdClientsRequest) ExcludeFields(excludeFields []string) ApiGetListsIdClientsRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetListsIdClientsRequest) Execute() (*EmailClients, *http.Response, error) {
	return r.ApiService.GetListsIdClientsExecute(r)
}

/*
GetListsIdClients List top email clients

Get a list of the top email clients based on user-agent strings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiGetListsIdClientsRequest
*/
func (a *ListsAPIService) GetListsIdClients(ctx context.Context, listId string) ApiGetListsIdClientsRequest {
	return ApiGetListsIdClientsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return EmailClients
func (a *ListsAPIService) GetListsIdClientsExecute(r ApiGetListsIdClientsRequest) (*EmailClients, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmailClients
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdClients")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/clients"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdGrowthHistoryRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	sortField *string
	sortDir *string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdGrowthHistoryRequest) Fields(fields []string) ApiGetListsIdGrowthHistoryRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdGrowthHistoryRequest) ExcludeFields(excludeFields []string) ApiGetListsIdGrowthHistoryRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetListsIdGrowthHistoryRequest) Count(count int32) ApiGetListsIdGrowthHistoryRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetListsIdGrowthHistoryRequest) Offset(offset int32) ApiGetListsIdGrowthHistoryRequest {
	r.offset = &offset
	return r
}

// Returns files sorted by the specified field.
func (r ApiGetListsIdGrowthHistoryRequest) SortField(sortField string) ApiGetListsIdGrowthHistoryRequest {
	r.sortField = &sortField
	return r
}

// Determines the order direction for sorted results.
func (r ApiGetListsIdGrowthHistoryRequest) SortDir(sortDir string) ApiGetListsIdGrowthHistoryRequest {
	r.sortDir = &sortDir
	return r
}

func (r ApiGetListsIdGrowthHistoryRequest) Execute() (*GrowthHistory, *http.Response, error) {
	return r.ApiService.GetListsIdGrowthHistoryExecute(r)
}

/*
GetListsIdGrowthHistory List growth history data

Get a month-by-month summary of a specific list's growth activity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiGetListsIdGrowthHistoryRequest
*/
func (a *ListsAPIService) GetListsIdGrowthHistory(ctx context.Context, listId string) ApiGetListsIdGrowthHistoryRequest {
	return ApiGetListsIdGrowthHistoryRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return GrowthHistory
func (a *ListsAPIService) GetListsIdGrowthHistoryExecute(r ApiGetListsIdGrowthHistoryRequest) (*GrowthHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GrowthHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdGrowthHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/growth-history"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
	}
	if r.sortDir != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_dir", r.sortDir, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdGrowthHistoryIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	month string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdGrowthHistoryIdRequest) Fields(fields []string) ApiGetListsIdGrowthHistoryIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdGrowthHistoryIdRequest) ExcludeFields(excludeFields []string) ApiGetListsIdGrowthHistoryIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetListsIdGrowthHistoryIdRequest) Execute() (*GrowthHistory, *http.Response, error) {
	return r.ApiService.GetListsIdGrowthHistoryIdExecute(r)
}

/*
GetListsIdGrowthHistoryId Get growth history by month

Get a summary of a specific list's growth activity for a specific month and year.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param month A specific month of list growth history.
 @return ApiGetListsIdGrowthHistoryIdRequest
*/
func (a *ListsAPIService) GetListsIdGrowthHistoryId(ctx context.Context, listId string, month string) ApiGetListsIdGrowthHistoryIdRequest {
	return ApiGetListsIdGrowthHistoryIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		month: month,
	}
}

// Execute executes the request
//  @return GrowthHistory
func (a *ListsAPIService) GetListsIdGrowthHistoryIdExecute(r ApiGetListsIdGrowthHistoryIdRequest) (*GrowthHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GrowthHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdGrowthHistoryId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/growth-history/{month}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"month"+"}", url.PathEscape(parameterValueToString(r.month, "month")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdInterestCategoriesRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	type_ *string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdInterestCategoriesRequest) Fields(fields []string) ApiGetListsIdInterestCategoriesRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdInterestCategoriesRequest) ExcludeFields(excludeFields []string) ApiGetListsIdInterestCategoriesRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetListsIdInterestCategoriesRequest) Count(count int32) ApiGetListsIdInterestCategoriesRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetListsIdInterestCategoriesRequest) Offset(offset int32) ApiGetListsIdInterestCategoriesRequest {
	r.offset = &offset
	return r
}

// Restrict results a type of interest group
func (r ApiGetListsIdInterestCategoriesRequest) Type_(type_ string) ApiGetListsIdInterestCategoriesRequest {
	r.type_ = &type_
	return r
}

func (r ApiGetListsIdInterestCategoriesRequest) Execute() (*InterestGroupings, *http.Response, error) {
	return r.ApiService.GetListsIdInterestCategoriesExecute(r)
}

/*
GetListsIdInterestCategories List interest categories

Get information about a list's interest categories.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiGetListsIdInterestCategoriesRequest
*/
func (a *ListsAPIService) GetListsIdInterestCategories(ctx context.Context, listId string) ApiGetListsIdInterestCategoriesRequest {
	return ApiGetListsIdInterestCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return InterestGroupings
func (a *ListsAPIService) GetListsIdInterestCategoriesExecute(r ApiGetListsIdInterestCategoriesRequest) (*InterestGroupings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterestGroupings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdInterestCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdInterestCategoriesIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	interestCategoryId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdInterestCategoriesIdRequest) Fields(fields []string) ApiGetListsIdInterestCategoriesIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdInterestCategoriesIdRequest) ExcludeFields(excludeFields []string) ApiGetListsIdInterestCategoriesIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetListsIdInterestCategoriesIdRequest) Execute() (*InterestCategory, *http.Response, error) {
	return r.ApiService.GetListsIdInterestCategoriesIdExecute(r)
}

/*
GetListsIdInterestCategoriesId Get interest category info

Get information about a specific interest category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param interestCategoryId The unique ID for the interest category.
 @return ApiGetListsIdInterestCategoriesIdRequest
*/
func (a *ListsAPIService) GetListsIdInterestCategoriesId(ctx context.Context, listId string, interestCategoryId string) ApiGetListsIdInterestCategoriesIdRequest {
	return ApiGetListsIdInterestCategoriesIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		interestCategoryId: interestCategoryId,
	}
}

// Execute executes the request
//  @return InterestCategory
func (a *ListsAPIService) GetListsIdInterestCategoriesIdExecute(r ApiGetListsIdInterestCategoriesIdRequest) (*InterestCategory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterestCategory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdInterestCategoriesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories/{interest_category_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_category_id"+"}", url.PathEscape(parameterValueToString(r.interestCategoryId, "interestCategoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdInterestCategoriesIdInterestsRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	interestCategoryId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdInterestCategoriesIdInterestsRequest) Fields(fields []string) ApiGetListsIdInterestCategoriesIdInterestsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdInterestCategoriesIdInterestsRequest) ExcludeFields(excludeFields []string) ApiGetListsIdInterestCategoriesIdInterestsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetListsIdInterestCategoriesIdInterestsRequest) Count(count int32) ApiGetListsIdInterestCategoriesIdInterestsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetListsIdInterestCategoriesIdInterestsRequest) Offset(offset int32) ApiGetListsIdInterestCategoriesIdInterestsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetListsIdInterestCategoriesIdInterestsRequest) Execute() (*Interests, *http.Response, error) {
	return r.ApiService.GetListsIdInterestCategoriesIdInterestsExecute(r)
}

/*
GetListsIdInterestCategoriesIdInterests List interests in category

Get a list of this category's interests.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param interestCategoryId The unique ID for the interest category.
 @return ApiGetListsIdInterestCategoriesIdInterestsRequest
*/
func (a *ListsAPIService) GetListsIdInterestCategoriesIdInterests(ctx context.Context, listId string, interestCategoryId string) ApiGetListsIdInterestCategoriesIdInterestsRequest {
	return ApiGetListsIdInterestCategoriesIdInterestsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		interestCategoryId: interestCategoryId,
	}
}

// Execute executes the request
//  @return Interests
func (a *ListsAPIService) GetListsIdInterestCategoriesIdInterestsExecute(r ApiGetListsIdInterestCategoriesIdInterestsRequest) (*Interests, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interests
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdInterestCategoriesIdInterests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories/{interest_category_id}/interests"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_category_id"+"}", url.PathEscape(parameterValueToString(r.interestCategoryId, "interestCategoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdInterestCategoriesIdInterestsIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	interestCategoryId string
	interestId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdInterestCategoriesIdInterestsIdRequest) Fields(fields []string) ApiGetListsIdInterestCategoriesIdInterestsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdInterestCategoriesIdInterestsIdRequest) ExcludeFields(excludeFields []string) ApiGetListsIdInterestCategoriesIdInterestsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetListsIdInterestCategoriesIdInterestsIdRequest) Execute() (*Interest, *http.Response, error) {
	return r.ApiService.GetListsIdInterestCategoriesIdInterestsIdExecute(r)
}

/*
GetListsIdInterestCategoriesIdInterestsId Get interest in category

Get interests or 'group names' for a specific category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param interestCategoryId The unique ID for the interest category.
 @param interestId The specific interest or 'group name'.
 @return ApiGetListsIdInterestCategoriesIdInterestsIdRequest
*/
func (a *ListsAPIService) GetListsIdInterestCategoriesIdInterestsId(ctx context.Context, listId string, interestCategoryId string, interestId string) ApiGetListsIdInterestCategoriesIdInterestsIdRequest {
	return ApiGetListsIdInterestCategoriesIdInterestsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		interestCategoryId: interestCategoryId,
		interestId: interestId,
	}
}

// Execute executes the request
//  @return Interest
func (a *ListsAPIService) GetListsIdInterestCategoriesIdInterestsIdExecute(r ApiGetListsIdInterestCategoriesIdInterestsIdRequest) (*Interest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdInterestCategoriesIdInterestsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories/{interest_category_id}/interests/{interest_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_category_id"+"}", url.PathEscape(parameterValueToString(r.interestCategoryId, "interestCategoryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_id"+"}", url.PathEscape(parameterValueToString(r.interestId, "interestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdLocationsRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdLocationsRequest) Fields(fields []string) ApiGetListsIdLocationsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdLocationsRequest) ExcludeFields(excludeFields []string) ApiGetListsIdLocationsRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetListsIdLocationsRequest) Execute() (*ListLocations, *http.Response, error) {
	return r.ApiService.GetListsIdLocationsExecute(r)
}

/*
GetListsIdLocations List locations

Get the locations (countries) that the list's subscribers have been tagged to based on geocoding their IP address.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiGetListsIdLocationsRequest
*/
func (a *ListsAPIService) GetListsIdLocations(ctx context.Context, listId string) ApiGetListsIdLocationsRequest {
	return ApiGetListsIdLocationsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return ListLocations
func (a *ListsAPIService) GetListsIdLocationsExecute(r ApiGetListsIdLocationsRequest) (*ListLocations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListLocations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/locations"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdMembersRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	emailType *string
	status *string
	sinceTimestampOpt *string
	beforeTimestampOpt *string
	sinceLastChanged *string
	beforeLastChanged *string
	uniqueEmailId *string
	vipOnly *bool
	interestCategoryId *string
	interestIds *string
	interestMatch *string
	sortField *string
	sortDir *string
	sinceLastCampaign *bool
	unsubscribedSince *string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMembersRequest) Fields(fields []string) ApiGetListsIdMembersRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMembersRequest) ExcludeFields(excludeFields []string) ApiGetListsIdMembersRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetListsIdMembersRequest) Count(count int32) ApiGetListsIdMembersRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetListsIdMembersRequest) Offset(offset int32) ApiGetListsIdMembersRequest {
	r.offset = &offset
	return r
}

// The email type.
func (r ApiGetListsIdMembersRequest) EmailType(emailType string) ApiGetListsIdMembersRequest {
	r.emailType = &emailType
	return r
}

// The subscriber&#39;s status.
func (r ApiGetListsIdMembersRequest) Status(status string) ApiGetListsIdMembersRequest {
	r.status = &status
	return r
}

// Restrict results to subscribers who opted-in after the set timeframe. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiGetListsIdMembersRequest) SinceTimestampOpt(sinceTimestampOpt string) ApiGetListsIdMembersRequest {
	r.sinceTimestampOpt = &sinceTimestampOpt
	return r
}

// Restrict results to subscribers who opted-in before the set timeframe. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiGetListsIdMembersRequest) BeforeTimestampOpt(beforeTimestampOpt string) ApiGetListsIdMembersRequest {
	r.beforeTimestampOpt = &beforeTimestampOpt
	return r
}

// Restrict results to subscribers whose information changed after the set timeframe. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiGetListsIdMembersRequest) SinceLastChanged(sinceLastChanged string) ApiGetListsIdMembersRequest {
	r.sinceLastChanged = &sinceLastChanged
	return r
}

// Restrict results to subscribers whose information changed before the set timeframe. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiGetListsIdMembersRequest) BeforeLastChanged(beforeLastChanged string) ApiGetListsIdMembersRequest {
	r.beforeLastChanged = &beforeLastChanged
	return r
}

// A unique identifier for the email address across all Mailchimp lists.
func (r ApiGetListsIdMembersRequest) UniqueEmailId(uniqueEmailId string) ApiGetListsIdMembersRequest {
	r.uniqueEmailId = &uniqueEmailId
	return r
}

// A filter to return only the list&#39;s VIP members. Passing &#x60;true&#x60; will restrict results to VIP list members, passing &#x60;false&#x60; will return all list members.
func (r ApiGetListsIdMembersRequest) VipOnly(vipOnly bool) ApiGetListsIdMembersRequest {
	r.vipOnly = &vipOnly
	return r
}

// The unique id for the interest category.
func (r ApiGetListsIdMembersRequest) InterestCategoryId(interestCategoryId string) ApiGetListsIdMembersRequest {
	r.interestCategoryId = &interestCategoryId
	return r
}

// Used to filter list members by interests. Must be accompanied by interest_category_id and interest_match. The value must be a comma separated list of interest ids present for any supplied interest categories.
func (r ApiGetListsIdMembersRequest) InterestIds(interestIds string) ApiGetListsIdMembersRequest {
	r.interestIds = &interestIds
	return r
}

// Used to filter list members by interests. Must be accompanied by interest_category_id and interest_ids. \&quot;any\&quot; will match a member with any of the interest supplied, \&quot;all\&quot; will only match members with every interest supplied, and \&quot;none\&quot; will match members without any of the interest supplied.
func (r ApiGetListsIdMembersRequest) InterestMatch(interestMatch string) ApiGetListsIdMembersRequest {
	r.interestMatch = &interestMatch
	return r
}

// Returns files sorted by the specified field.
func (r ApiGetListsIdMembersRequest) SortField(sortField string) ApiGetListsIdMembersRequest {
	r.sortField = &sortField
	return r
}

// Determines the order direction for sorted results.
func (r ApiGetListsIdMembersRequest) SortDir(sortDir string) ApiGetListsIdMembersRequest {
	r.sortDir = &sortDir
	return r
}

// Filter subscribers by those subscribed/unsubscribed/pending/cleaned since last email campaign send. Member status is required to use this filter.
func (r ApiGetListsIdMembersRequest) SinceLastCampaign(sinceLastCampaign bool) ApiGetListsIdMembersRequest {
	r.sinceLastCampaign = &sinceLastCampaign
	return r
}

// Filter subscribers by those unsubscribed since a specific date. Using any status other than unsubscribed with this filter will result in an error.
func (r ApiGetListsIdMembersRequest) UnsubscribedSince(unsubscribedSince string) ApiGetListsIdMembersRequest {
	r.unsubscribedSince = &unsubscribedSince
	return r
}

func (r ApiGetListsIdMembersRequest) Execute() (*ListMembers2, *http.Response, error) {
	return r.ApiService.GetListsIdMembersExecute(r)
}

/*
GetListsIdMembers List members info

Get information about members in a specific Mailchimp list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiGetListsIdMembersRequest
*/
func (a *ListsAPIService) GetListsIdMembers(ctx context.Context, listId string) ApiGetListsIdMembersRequest {
	return ApiGetListsIdMembersRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return ListMembers2
func (a *ListsAPIService) GetListsIdMembersExecute(r ApiGetListsIdMembersRequest) (*ListMembers2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMembers2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMembers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.emailType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email_type", r.emailType, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.sinceTimestampOpt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_timestamp_opt", r.sinceTimestampOpt, "")
	}
	if r.beforeTimestampOpt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_timestamp_opt", r.beforeTimestampOpt, "")
	}
	if r.sinceLastChanged != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_last_changed", r.sinceLastChanged, "")
	}
	if r.beforeLastChanged != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_last_changed", r.beforeLastChanged, "")
	}
	if r.uniqueEmailId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unique_email_id", r.uniqueEmailId, "")
	}
	if r.vipOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vip_only", r.vipOnly, "")
	}
	if r.interestCategoryId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interest_category_id", r.interestCategoryId, "")
	}
	if r.interestIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interest_ids", r.interestIds, "")
	}
	if r.interestMatch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interest_match", r.interestMatch, "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
	}
	if r.sortDir != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_dir", r.sortDir, "")
	}
	if r.sinceLastCampaign != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_last_campaign", r.sinceLastCampaign, "")
	}
	if r.unsubscribedSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unsubscribed_since", r.unsubscribedSince, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdMembersIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	subscriberHash string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMembersIdRequest) Fields(fields []string) ApiGetListsIdMembersIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMembersIdRequest) ExcludeFields(excludeFields []string) ApiGetListsIdMembersIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetListsIdMembersIdRequest) Execute() (*ListMembers2, *http.Response, error) {
	return r.ApiService.GetListsIdMembersIdExecute(r)
}

/*
GetListsIdMembersId Get member info

Get information about a specific list member, including a currently subscribed, unsubscribed, or bounced member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ApiGetListsIdMembersIdRequest
*/
func (a *ListsAPIService) GetListsIdMembersId(ctx context.Context, listId string, subscriberHash string) ApiGetListsIdMembersIdRequest {
	return ApiGetListsIdMembersIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return ListMembers2
func (a *ListsAPIService) GetListsIdMembersIdExecute(r ApiGetListsIdMembersIdRequest) (*ListMembers2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMembers2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMembersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdMembersIdActivityRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	subscriberHash string
	fields *[]string
	excludeFields *[]string
	action *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMembersIdActivityRequest) Fields(fields []string) ApiGetListsIdMembersIdActivityRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMembersIdActivityRequest) ExcludeFields(excludeFields []string) ApiGetListsIdMembersIdActivityRequest {
	r.excludeFields = &excludeFields
	return r
}

// A comma seperated list of actions to return.
func (r ApiGetListsIdMembersIdActivityRequest) Action(action []string) ApiGetListsIdMembersIdActivityRequest {
	r.action = &action
	return r
}

func (r ApiGetListsIdMembersIdActivityRequest) Execute() (*MemberActivityEvents, *http.Response, error) {
	return r.ApiService.GetListsIdMembersIdActivityExecute(r)
}

/*
GetListsIdMembersIdActivity View recent activity 50

Get the last 50 events of a member's activity on a specific list, including opens, clicks, and unsubscribes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ApiGetListsIdMembersIdActivityRequest
*/
func (a *ListsAPIService) GetListsIdMembersIdActivity(ctx context.Context, listId string, subscriberHash string) ApiGetListsIdMembersIdActivityRequest {
	return ApiGetListsIdMembersIdActivityRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return MemberActivityEvents
func (a *ListsAPIService) GetListsIdMembersIdActivityExecute(r ApiGetListsIdMembersIdActivityRequest) (*MemberActivityEvents, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MemberActivityEvents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMembersIdActivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/activity"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.action != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "action", r.action, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdMembersIdActivityFeedRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	subscriberHash string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	activityFilters *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMembersIdActivityFeedRequest) Fields(fields []string) ApiGetListsIdMembersIdActivityFeedRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMembersIdActivityFeedRequest) ExcludeFields(excludeFields []string) ApiGetListsIdMembersIdActivityFeedRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetListsIdMembersIdActivityFeedRequest) Count(count int32) ApiGetListsIdMembersIdActivityFeedRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetListsIdMembersIdActivityFeedRequest) Offset(offset int32) ApiGetListsIdMembersIdActivityFeedRequest {
	r.offset = &offset
	return r
}

// A comma-separated list of activity filters that correspond to a set of activity types, e.g \&quot;?activity_filters&#x3D;open,bounce,click\&quot;.
func (r ApiGetListsIdMembersIdActivityFeedRequest) ActivityFilters(activityFilters []string) ApiGetListsIdMembersIdActivityFeedRequest {
	r.activityFilters = &activityFilters
	return r
}

func (r ApiGetListsIdMembersIdActivityFeedRequest) Execute() (*MemberActivityEvents1, *http.Response, error) {
	return r.ApiService.GetListsIdMembersIdActivityFeedExecute(r)
}

/*
GetListsIdMembersIdActivityFeed View recent activity

Get a member's activity on a specific list, including opens, clicks, and unsubscribes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
 @return ApiGetListsIdMembersIdActivityFeedRequest
*/
func (a *ListsAPIService) GetListsIdMembersIdActivityFeed(ctx context.Context, listId string, subscriberHash string) ApiGetListsIdMembersIdActivityFeedRequest {
	return ApiGetListsIdMembersIdActivityFeedRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return MemberActivityEvents1
func (a *ListsAPIService) GetListsIdMembersIdActivityFeedExecute(r ApiGetListsIdMembersIdActivityFeedRequest) (*MemberActivityEvents1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MemberActivityEvents1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMembersIdActivityFeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/activity-feed"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.activityFilters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activity_filters", r.activityFilters, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdMembersIdEventsRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	subscriberHash string
	count *int32
	offset *int32
	fields *[]string
	excludeFields *[]string
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetListsIdMembersIdEventsRequest) Count(count int32) ApiGetListsIdMembersIdEventsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetListsIdMembersIdEventsRequest) Offset(offset int32) ApiGetListsIdMembersIdEventsRequest {
	r.offset = &offset
	return r
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMembersIdEventsRequest) Fields(fields []string) ApiGetListsIdMembersIdEventsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMembersIdEventsRequest) ExcludeFields(excludeFields []string) ApiGetListsIdMembersIdEventsRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetListsIdMembersIdEventsRequest) Execute() (*CollectionOfEvents, *http.Response, error) {
	return r.ApiService.GetListsIdMembersIdEventsExecute(r)
}

/*
GetListsIdMembersIdEvents List member events

Get events for a contact.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ApiGetListsIdMembersIdEventsRequest
*/
func (a *ListsAPIService) GetListsIdMembersIdEvents(ctx context.Context, listId string, subscriberHash string) ApiGetListsIdMembersIdEventsRequest {
	return ApiGetListsIdMembersIdEventsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return CollectionOfEvents
func (a *ListsAPIService) GetListsIdMembersIdEventsExecute(r ApiGetListsIdMembersIdEventsRequest) (*CollectionOfEvents, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionOfEvents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMembersIdEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdMembersIdGoalsRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	subscriberHash string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMembersIdGoalsRequest) Fields(fields []string) ApiGetListsIdMembersIdGoalsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMembersIdGoalsRequest) ExcludeFields(excludeFields []string) ApiGetListsIdMembersIdGoalsRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetListsIdMembersIdGoalsRequest) Execute() (*CollectionOfMemberActivityEvents, *http.Response, error) {
	return r.ApiService.GetListsIdMembersIdGoalsExecute(r)
}

/*
GetListsIdMembersIdGoals List member goal events

Get the last 50 Goal events for a member on a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ApiGetListsIdMembersIdGoalsRequest
*/
func (a *ListsAPIService) GetListsIdMembersIdGoals(ctx context.Context, listId string, subscriberHash string) ApiGetListsIdMembersIdGoalsRequest {
	return ApiGetListsIdMembersIdGoalsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return CollectionOfMemberActivityEvents
func (a *ListsAPIService) GetListsIdMembersIdGoalsExecute(r ApiGetListsIdMembersIdGoalsRequest) (*CollectionOfMemberActivityEvents, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionOfMemberActivityEvents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMembersIdGoals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/goals"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdMembersIdNotesRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	subscriberHash string
	sortField *string
	sortDir *string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// Returns notes sorted by the specified field.
func (r ApiGetListsIdMembersIdNotesRequest) SortField(sortField string) ApiGetListsIdMembersIdNotesRequest {
	r.sortField = &sortField
	return r
}

// Determines the order direction for sorted results.
func (r ApiGetListsIdMembersIdNotesRequest) SortDir(sortDir string) ApiGetListsIdMembersIdNotesRequest {
	r.sortDir = &sortDir
	return r
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMembersIdNotesRequest) Fields(fields []string) ApiGetListsIdMembersIdNotesRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMembersIdNotesRequest) ExcludeFields(excludeFields []string) ApiGetListsIdMembersIdNotesRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetListsIdMembersIdNotesRequest) Count(count int32) ApiGetListsIdMembersIdNotesRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetListsIdMembersIdNotesRequest) Offset(offset int32) ApiGetListsIdMembersIdNotesRequest {
	r.offset = &offset
	return r
}

func (r ApiGetListsIdMembersIdNotesRequest) Execute() (*CollectionOfNotes, *http.Response, error) {
	return r.ApiService.GetListsIdMembersIdNotesExecute(r)
}

/*
GetListsIdMembersIdNotes List recent member notes

Get recent notes for a specific list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
 @return ApiGetListsIdMembersIdNotesRequest
*/
func (a *ListsAPIService) GetListsIdMembersIdNotes(ctx context.Context, listId string, subscriberHash string) ApiGetListsIdMembersIdNotesRequest {
	return ApiGetListsIdMembersIdNotesRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return CollectionOfNotes
func (a *ListsAPIService) GetListsIdMembersIdNotesExecute(r ApiGetListsIdMembersIdNotesRequest) (*CollectionOfNotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionOfNotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMembersIdNotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/notes"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
	}
	if r.sortDir != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_dir", r.sortDir, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdMembersIdNotesIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	subscriberHash string
	noteId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMembersIdNotesIdRequest) Fields(fields []string) ApiGetListsIdMembersIdNotesIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMembersIdNotesIdRequest) ExcludeFields(excludeFields []string) ApiGetListsIdMembersIdNotesIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetListsIdMembersIdNotesIdRequest) Execute() (*MemberNotes, *http.Response, error) {
	return r.ApiService.GetListsIdMembersIdNotesIdExecute(r)
}

/*
GetListsIdMembersIdNotesId Get member note

Get a specific note for a specific list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @param noteId The id for the note.
 @return ApiGetListsIdMembersIdNotesIdRequest
*/
func (a *ListsAPIService) GetListsIdMembersIdNotesId(ctx context.Context, listId string, subscriberHash string, noteId string) ApiGetListsIdMembersIdNotesIdRequest {
	return ApiGetListsIdMembersIdNotesIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
		noteId: noteId,
	}
}

// Execute executes the request
//  @return MemberNotes
func (a *ListsAPIService) GetListsIdMembersIdNotesIdExecute(r ApiGetListsIdMembersIdNotesIdRequest) (*MemberNotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MemberNotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMembersIdNotesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/notes/{note_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"note_id"+"}", url.PathEscape(parameterValueToString(r.noteId, "noteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdMergeFieldsRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	type_ *string
	required *bool
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMergeFieldsRequest) Fields(fields []string) ApiGetListsIdMergeFieldsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMergeFieldsRequest) ExcludeFields(excludeFields []string) ApiGetListsIdMergeFieldsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetListsIdMergeFieldsRequest) Count(count int32) ApiGetListsIdMergeFieldsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetListsIdMergeFieldsRequest) Offset(offset int32) ApiGetListsIdMergeFieldsRequest {
	r.offset = &offset
	return r
}

// The merge field type.
func (r ApiGetListsIdMergeFieldsRequest) Type_(type_ string) ApiGetListsIdMergeFieldsRequest {
	r.type_ = &type_
	return r
}

// Whether it&#39;s a required merge field.
func (r ApiGetListsIdMergeFieldsRequest) Required(required bool) ApiGetListsIdMergeFieldsRequest {
	r.required = &required
	return r
}

func (r ApiGetListsIdMergeFieldsRequest) Execute() (*CollectionOfMergeFields, *http.Response, error) {
	return r.ApiService.GetListsIdMergeFieldsExecute(r)
}

/*
GetListsIdMergeFields List merge fields

Get a list of all merge fields for an audience.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiGetListsIdMergeFieldsRequest
*/
func (a *ListsAPIService) GetListsIdMergeFields(ctx context.Context, listId string) ApiGetListsIdMergeFieldsRequest {
	return ApiGetListsIdMergeFieldsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return CollectionOfMergeFields
func (a *ListsAPIService) GetListsIdMergeFieldsExecute(r ApiGetListsIdMergeFieldsRequest) (*CollectionOfMergeFields, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionOfMergeFields
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMergeFields")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/merge-fields"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.required != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "required", r.required, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdMergeFieldsIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	mergeId string
	excludeFields *[]string
	fields *[]string
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMergeFieldsIdRequest) ExcludeFields(excludeFields []string) ApiGetListsIdMergeFieldsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdMergeFieldsIdRequest) Fields(fields []string) ApiGetListsIdMergeFieldsIdRequest {
	r.fields = &fields
	return r
}

func (r ApiGetListsIdMergeFieldsIdRequest) Execute() (*MergeField, *http.Response, error) {
	return r.ApiService.GetListsIdMergeFieldsIdExecute(r)
}

/*
GetListsIdMergeFieldsId Get merge field

Get information about a specific merge field.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param mergeId The id for the merge field.
 @return ApiGetListsIdMergeFieldsIdRequest
*/
func (a *ListsAPIService) GetListsIdMergeFieldsId(ctx context.Context, listId string, mergeId string) ApiGetListsIdMergeFieldsIdRequest {
	return ApiGetListsIdMergeFieldsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		mergeId: mergeId,
	}
}

// Execute executes the request
//  @return MergeField
func (a *ListsAPIService) GetListsIdMergeFieldsIdExecute(r ApiGetListsIdMergeFieldsIdRequest) (*MergeField, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MergeField
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMergeFieldsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/merge-fields/{merge_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_id"+"}", url.PathEscape(parameterValueToString(r.mergeId, "mergeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdSegmentsIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	segmentId string
	fields *[]string
	excludeFields *[]string
	includeCleaned *bool
	includeTransactional *bool
	includeUnsubscribed *bool
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdSegmentsIdRequest) Fields(fields []string) ApiGetListsIdSegmentsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdSegmentsIdRequest) ExcludeFields(excludeFields []string) ApiGetListsIdSegmentsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

// Include cleaned members in response
func (r ApiGetListsIdSegmentsIdRequest) IncludeCleaned(includeCleaned bool) ApiGetListsIdSegmentsIdRequest {
	r.includeCleaned = &includeCleaned
	return r
}

// Include transactional members in response
func (r ApiGetListsIdSegmentsIdRequest) IncludeTransactional(includeTransactional bool) ApiGetListsIdSegmentsIdRequest {
	r.includeTransactional = &includeTransactional
	return r
}

// Include unsubscribed members in response
func (r ApiGetListsIdSegmentsIdRequest) IncludeUnsubscribed(includeUnsubscribed bool) ApiGetListsIdSegmentsIdRequest {
	r.includeUnsubscribed = &includeUnsubscribed
	return r
}

func (r ApiGetListsIdSegmentsIdRequest) Execute() (*List7, *http.Response, error) {
	return r.ApiService.GetListsIdSegmentsIdExecute(r)
}

/*
GetListsIdSegmentsId Get segment info

Get information about a specific segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param segmentId The unique id for the segment.
 @return ApiGetListsIdSegmentsIdRequest
*/
func (a *ListsAPIService) GetListsIdSegmentsId(ctx context.Context, listId string, segmentId string) ApiGetListsIdSegmentsIdRequest {
	return ApiGetListsIdSegmentsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		segmentId: segmentId,
	}
}

// Execute executes the request
//  @return List7
func (a *ListsAPIService) GetListsIdSegmentsIdExecute(r ApiGetListsIdSegmentsIdRequest) (*List7, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *List7
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdSegmentsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments/{segment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segment_id"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.includeCleaned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_cleaned", r.includeCleaned, "")
	}
	if r.includeTransactional != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_transactional", r.includeTransactional, "")
	}
	if r.includeUnsubscribed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unsubscribed", r.includeUnsubscribed, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdSegmentsIdMembersRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	segmentId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	includeCleaned *bool
	includeTransactional *bool
	includeUnsubscribed *bool
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdSegmentsIdMembersRequest) Fields(fields []string) ApiGetListsIdSegmentsIdMembersRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetListsIdSegmentsIdMembersRequest) ExcludeFields(excludeFields []string) ApiGetListsIdSegmentsIdMembersRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetListsIdSegmentsIdMembersRequest) Count(count int32) ApiGetListsIdSegmentsIdMembersRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetListsIdSegmentsIdMembersRequest) Offset(offset int32) ApiGetListsIdSegmentsIdMembersRequest {
	r.offset = &offset
	return r
}

// Include cleaned members in response
func (r ApiGetListsIdSegmentsIdMembersRequest) IncludeCleaned(includeCleaned bool) ApiGetListsIdSegmentsIdMembersRequest {
	r.includeCleaned = &includeCleaned
	return r
}

// Include transactional members in response
func (r ApiGetListsIdSegmentsIdMembersRequest) IncludeTransactional(includeTransactional bool) ApiGetListsIdSegmentsIdMembersRequest {
	r.includeTransactional = &includeTransactional
	return r
}

// Include unsubscribed members in response
func (r ApiGetListsIdSegmentsIdMembersRequest) IncludeUnsubscribed(includeUnsubscribed bool) ApiGetListsIdSegmentsIdMembersRequest {
	r.includeUnsubscribed = &includeUnsubscribed
	return r
}

func (r ApiGetListsIdSegmentsIdMembersRequest) Execute() (*SegmentMembers, *http.Response, error) {
	return r.ApiService.GetListsIdSegmentsIdMembersExecute(r)
}

/*
GetListsIdSegmentsIdMembers List members in segment

Get information about members in a saved segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param segmentId The unique id for the segment.
 @return ApiGetListsIdSegmentsIdMembersRequest
*/
func (a *ListsAPIService) GetListsIdSegmentsIdMembers(ctx context.Context, listId string, segmentId string) ApiGetListsIdSegmentsIdMembersRequest {
	return ApiGetListsIdSegmentsIdMembersRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		segmentId: segmentId,
	}
}

// Execute executes the request
//  @return SegmentMembers
func (a *ListsAPIService) GetListsIdSegmentsIdMembersExecute(r ApiGetListsIdSegmentsIdMembersRequest) (*SegmentMembers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SegmentMembers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdSegmentsIdMembers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments/{segment_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segment_id"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.includeCleaned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_cleaned", r.includeCleaned, "")
	}
	if r.includeTransactional != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_transactional", r.includeTransactional, "")
	}
	if r.includeUnsubscribed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unsubscribed", r.includeUnsubscribed, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdSignupFormsRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
}

func (r ApiGetListsIdSignupFormsRequest) Execute() (*ListSignupForms, *http.Response, error) {
	return r.ApiService.GetListsIdSignupFormsExecute(r)
}

/*
GetListsIdSignupForms List signup forms

Get signup forms for a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiGetListsIdSignupFormsRequest
*/
func (a *ListsAPIService) GetListsIdSignupForms(ctx context.Context, listId string) ApiGetListsIdSignupFormsRequest {
	return ApiGetListsIdSignupFormsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return ListSignupForms
func (a *ListsAPIService) GetListsIdSignupFormsExecute(r ApiGetListsIdSignupFormsRequest) (*ListSignupForms, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListSignupForms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdSignupForms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/signup-forms"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdSurveysRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
}

func (r ApiGetListsIdSurveysRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetListsIdSurveysExecute(r)
}

/*
GetListsIdSurveys Get information about all surveys for a list

Get information about all available surveys for a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiGetListsIdSurveysRequest
*/
func (a *ListsAPIService) GetListsIdSurveys(ctx context.Context, listId string) ApiGetListsIdSurveysRequest {
	return ApiGetListsIdSurveysRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
func (a *ListsAPIService) GetListsIdSurveysExecute(r ApiGetListsIdSurveysRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdSurveys")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/surveys"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetListsIdSurveysIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	surveyId string
}

func (r ApiGetListsIdSurveysIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetListsIdSurveysIdExecute(r)
}

/*
GetListsIdSurveysId Get survey

Get details about a specific survey.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param surveyId The ID of the survey.
 @return ApiGetListsIdSurveysIdRequest
*/
func (a *ListsAPIService) GetListsIdSurveysId(ctx context.Context, listId string, surveyId string) ApiGetListsIdSurveysIdRequest {
	return ApiGetListsIdSurveysIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		surveyId: surveyId,
	}
}

// Execute executes the request
func (a *ListsAPIService) GetListsIdSurveysIdExecute(r ApiGetListsIdSurveysIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdSurveysId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/surveys/{survey_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"survey_id"+"}", url.PathEscape(parameterValueToString(r.surveyId, "surveyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetListsIdWebhooksRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
}

func (r ApiGetListsIdWebhooksRequest) Execute() (*ListWebhooks, *http.Response, error) {
	return r.ApiService.GetListsIdWebhooksExecute(r)
}

/*
GetListsIdWebhooks List webhooks

Get information about all webhooks for a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiGetListsIdWebhooksRequest
*/
func (a *ListsAPIService) GetListsIdWebhooks(ctx context.Context, listId string) ApiGetListsIdWebhooksRequest {
	return ApiGetListsIdWebhooksRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return ListWebhooks
func (a *ListsAPIService) GetListsIdWebhooksExecute(r ApiGetListsIdWebhooksRequest) (*ListWebhooks, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListWebhooks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdWebhooks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/webhooks"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListsIdWebhooksIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	webhookId string
}

func (r ApiGetListsIdWebhooksIdRequest) Execute() (*ListWebhooks, *http.Response, error) {
	return r.ApiService.GetListsIdWebhooksIdExecute(r)
}

/*
GetListsIdWebhooksId Get webhook info

Get information about a specific webhook.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param webhookId The webhook's id.
 @return ApiGetListsIdWebhooksIdRequest
*/
func (a *ListsAPIService) GetListsIdWebhooksId(ctx context.Context, listId string, webhookId string) ApiGetListsIdWebhooksIdRequest {
	return ApiGetListsIdWebhooksIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		webhookId: webhookId,
	}
}

// Execute executes the request
//  @return ListWebhooks
func (a *ListsAPIService) GetListsIdWebhooksIdExecute(r ApiGetListsIdWebhooksIdRequest) (*ListWebhooks, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListWebhooks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdWebhooksId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/webhooks/{webhook_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"webhook_id"+"}", url.PathEscape(parameterValueToString(r.webhookId, "webhookId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchListsIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	body *SubscriberList2
}

func (r ApiPatchListsIdRequest) Body(body SubscriberList2) ApiPatchListsIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchListsIdRequest) Execute() (*SubscriberList, *http.Response, error) {
	return r.ApiService.PatchListsIdExecute(r)
}

/*
PatchListsId Update lists

Update the settings for a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiPatchListsIdRequest
*/
func (a *ListsAPIService) PatchListsId(ctx context.Context, listId string) ApiPatchListsIdRequest {
	return ApiPatchListsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return SubscriberList
func (a *ListsAPIService) PatchListsIdExecute(r ApiPatchListsIdRequest) (*SubscriberList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriberList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PatchListsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchListsIdInterestCategoriesIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	interestCategoryId string
	body *InterestCategory1
}

func (r ApiPatchListsIdInterestCategoriesIdRequest) Body(body InterestCategory1) ApiPatchListsIdInterestCategoriesIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchListsIdInterestCategoriesIdRequest) Execute() (*InterestCategory, *http.Response, error) {
	return r.ApiService.PatchListsIdInterestCategoriesIdExecute(r)
}

/*
PatchListsIdInterestCategoriesId Update interest category

Update a specific interest category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param interestCategoryId The unique ID for the interest category.
 @return ApiPatchListsIdInterestCategoriesIdRequest
*/
func (a *ListsAPIService) PatchListsIdInterestCategoriesId(ctx context.Context, listId string, interestCategoryId string) ApiPatchListsIdInterestCategoriesIdRequest {
	return ApiPatchListsIdInterestCategoriesIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		interestCategoryId: interestCategoryId,
	}
}

// Execute executes the request
//  @return InterestCategory
func (a *ListsAPIService) PatchListsIdInterestCategoriesIdExecute(r ApiPatchListsIdInterestCategoriesIdRequest) (*InterestCategory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterestCategory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PatchListsIdInterestCategoriesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories/{interest_category_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_category_id"+"}", url.PathEscape(parameterValueToString(r.interestCategoryId, "interestCategoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchListsIdInterestCategoriesIdInterestsIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	interestCategoryId string
	interestId string
	body *Interest1
}

func (r ApiPatchListsIdInterestCategoriesIdInterestsIdRequest) Body(body Interest1) ApiPatchListsIdInterestCategoriesIdInterestsIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchListsIdInterestCategoriesIdInterestsIdRequest) Execute() (*Interest, *http.Response, error) {
	return r.ApiService.PatchListsIdInterestCategoriesIdInterestsIdExecute(r)
}

/*
PatchListsIdInterestCategoriesIdInterestsId Update interest in category

Update interests or 'group names' for a specific category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param interestCategoryId The unique ID for the interest category.
 @param interestId The specific interest or 'group name'.
 @return ApiPatchListsIdInterestCategoriesIdInterestsIdRequest
*/
func (a *ListsAPIService) PatchListsIdInterestCategoriesIdInterestsId(ctx context.Context, listId string, interestCategoryId string, interestId string) ApiPatchListsIdInterestCategoriesIdInterestsIdRequest {
	return ApiPatchListsIdInterestCategoriesIdInterestsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		interestCategoryId: interestCategoryId,
		interestId: interestId,
	}
}

// Execute executes the request
//  @return Interest
func (a *ListsAPIService) PatchListsIdInterestCategoriesIdInterestsIdExecute(r ApiPatchListsIdInterestCategoriesIdInterestsIdRequest) (*Interest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PatchListsIdInterestCategoriesIdInterestsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories/{interest_category_id}/interests/{interest_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_category_id"+"}", url.PathEscape(parameterValueToString(r.interestCategoryId, "interestCategoryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_id"+"}", url.PathEscape(parameterValueToString(r.interestId, "interestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchListsIdMembersIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	subscriberHash string
	body *AddListMembers3
	skipMergeValidation *bool
}

func (r ApiPatchListsIdMembersIdRequest) Body(body AddListMembers3) ApiPatchListsIdMembersIdRequest {
	r.body = &body
	return r
}

// If skip_merge_validation is true, member data will be accepted without merge field values, even if the merge field is usually required. This defaults to false.
func (r ApiPatchListsIdMembersIdRequest) SkipMergeValidation(skipMergeValidation bool) ApiPatchListsIdMembersIdRequest {
	r.skipMergeValidation = &skipMergeValidation
	return r
}

func (r ApiPatchListsIdMembersIdRequest) Execute() (*ListMembers2, *http.Response, error) {
	return r.ApiService.PatchListsIdMembersIdExecute(r)
}

/*
PatchListsIdMembersId Update list member

Update information for a specific list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ApiPatchListsIdMembersIdRequest
*/
func (a *ListsAPIService) PatchListsIdMembersId(ctx context.Context, listId string, subscriberHash string) ApiPatchListsIdMembersIdRequest {
	return ApiPatchListsIdMembersIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return ListMembers2
func (a *ListsAPIService) PatchListsIdMembersIdExecute(r ApiPatchListsIdMembersIdRequest) (*ListMembers2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMembers2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PatchListsIdMembersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.skipMergeValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_merge_validation", r.skipMergeValidation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchListsIdMembersIdNotesIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	subscriberHash string
	noteId string
	body *MemberNotes1
}

func (r ApiPatchListsIdMembersIdNotesIdRequest) Body(body MemberNotes1) ApiPatchListsIdMembersIdNotesIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchListsIdMembersIdNotesIdRequest) Execute() (*MemberNotes, *http.Response, error) {
	return r.ApiService.PatchListsIdMembersIdNotesIdExecute(r)
}

/*
PatchListsIdMembersIdNotesId Update note

Update a specific note for a specific list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @param noteId The id for the note.
 @return ApiPatchListsIdMembersIdNotesIdRequest
*/
func (a *ListsAPIService) PatchListsIdMembersIdNotesId(ctx context.Context, listId string, subscriberHash string, noteId string) ApiPatchListsIdMembersIdNotesIdRequest {
	return ApiPatchListsIdMembersIdNotesIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
		noteId: noteId,
	}
}

// Execute executes the request
//  @return MemberNotes
func (a *ListsAPIService) PatchListsIdMembersIdNotesIdExecute(r ApiPatchListsIdMembersIdNotesIdRequest) (*MemberNotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MemberNotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PatchListsIdMembersIdNotesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/notes/{note_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"note_id"+"}", url.PathEscape(parameterValueToString(r.noteId, "noteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchListsIdMergeFieldsIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	mergeId string
	body *MergeField2
}

func (r ApiPatchListsIdMergeFieldsIdRequest) Body(body MergeField2) ApiPatchListsIdMergeFieldsIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchListsIdMergeFieldsIdRequest) Execute() (*MergeField, *http.Response, error) {
	return r.ApiService.PatchListsIdMergeFieldsIdExecute(r)
}

/*
PatchListsIdMergeFieldsId Update merge field

Update a specific merge field.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param mergeId The id for the merge field.
 @return ApiPatchListsIdMergeFieldsIdRequest
*/
func (a *ListsAPIService) PatchListsIdMergeFieldsId(ctx context.Context, listId string, mergeId string) ApiPatchListsIdMergeFieldsIdRequest {
	return ApiPatchListsIdMergeFieldsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		mergeId: mergeId,
	}
}

// Execute executes the request
//  @return MergeField
func (a *ListsAPIService) PatchListsIdMergeFieldsIdExecute(r ApiPatchListsIdMergeFieldsIdRequest) (*MergeField, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MergeField
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PatchListsIdMergeFieldsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/merge-fields/{merge_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_id"+"}", url.PathEscape(parameterValueToString(r.mergeId, "mergeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchListsIdSegmentsIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	segmentId string
	body *List9
}

func (r ApiPatchListsIdSegmentsIdRequest) Body(body List9) ApiPatchListsIdSegmentsIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchListsIdSegmentsIdRequest) Execute() (*List7, *http.Response, error) {
	return r.ApiService.PatchListsIdSegmentsIdExecute(r)
}

/*
PatchListsIdSegmentsId Update segment

Update a specific segment in a list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param segmentId The unique id for the segment.
 @return ApiPatchListsIdSegmentsIdRequest
*/
func (a *ListsAPIService) PatchListsIdSegmentsId(ctx context.Context, listId string, segmentId string) ApiPatchListsIdSegmentsIdRequest {
	return ApiPatchListsIdSegmentsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		segmentId: segmentId,
	}
}

// Execute executes the request
//  @return List7
func (a *ListsAPIService) PatchListsIdSegmentsIdExecute(r ApiPatchListsIdSegmentsIdRequest) (*List7, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *List7
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PatchListsIdSegmentsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments/{segment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segment_id"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchListsIdWebhooksIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	webhookId string
	body *AddWebhook
}

func (r ApiPatchListsIdWebhooksIdRequest) Body(body AddWebhook) ApiPatchListsIdWebhooksIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchListsIdWebhooksIdRequest) Execute() (*ListWebhooks, *http.Response, error) {
	return r.ApiService.PatchListsIdWebhooksIdExecute(r)
}

/*
PatchListsIdWebhooksId Update webhook

Update the settings for an existing webhook.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param webhookId The webhook's id.
 @return ApiPatchListsIdWebhooksIdRequest
*/
func (a *ListsAPIService) PatchListsIdWebhooksId(ctx context.Context, listId string, webhookId string) ApiPatchListsIdWebhooksIdRequest {
	return ApiPatchListsIdWebhooksIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		webhookId: webhookId,
	}
}

// Execute executes the request
//  @return ListWebhooks
func (a *ListsAPIService) PatchListsIdWebhooksIdExecute(r ApiPatchListsIdWebhooksIdRequest) (*ListWebhooks, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListWebhooks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PatchListsIdWebhooksId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/webhooks/{webhook_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"webhook_id"+"}", url.PathEscape(parameterValueToString(r.webhookId, "webhookId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostListMemberEventsRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	subscriberHash string
	body *Events
}

func (r ApiPostListMemberEventsRequest) Body(body Events) ApiPostListMemberEventsRequest {
	r.body = &body
	return r
}

func (r ApiPostListMemberEventsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostListMemberEventsExecute(r)
}

/*
PostListMemberEvents Add event

Add an event for a list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ApiPostListMemberEventsRequest
*/
func (a *ListsAPIService) PostListMemberEvents(ctx context.Context, listId string, subscriberHash string) ApiPostListMemberEventsRequest {
	return ApiPostListMemberEventsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
func (a *ListsAPIService) PostListMemberEventsExecute(r ApiPostListMemberEventsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListMemberEvents")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostListMemberTagsRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	subscriberHash string
	body *MemberTags
}

func (r ApiPostListMemberTagsRequest) Body(body MemberTags) ApiPostListMemberTagsRequest {
	r.body = &body
	return r
}

func (r ApiPostListMemberTagsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostListMemberTagsExecute(r)
}

/*
PostListMemberTags Add or remove member tags

Add or remove tags from a list member. If a tag that does not exist is passed in and set as 'active', a new tag will be created.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
 @return ApiPostListMemberTagsRequest
*/
func (a *ListsAPIService) PostListMemberTags(ctx context.Context, listId string, subscriberHash string) ApiPostListMemberTagsRequest {
	return ApiPostListMemberTagsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
func (a *ListsAPIService) PostListMemberTagsExecute(r ApiPostListMemberTagsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListMemberTags")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostListsRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	body *SubscriberList1
}

func (r ApiPostListsRequest) Body(body SubscriberList1) ApiPostListsRequest {
	r.body = &body
	return r
}

func (r ApiPostListsRequest) Execute() (*SubscriberList, *http.Response, error) {
	return r.ApiService.PostListsExecute(r)
}

/*
PostLists Add list

Create a new list in your Mailchimp account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostListsRequest
*/
func (a *ListsAPIService) PostLists(ctx context.Context) ApiPostListsRequest {
	return ApiPostListsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubscriberList
func (a *ListsAPIService) PostListsExecute(r ApiPostListsRequest) (*SubscriberList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriberList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostLists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostListsIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	body *MembersToSubscribeUnsubscribeToFromAListInBatch
	skipMergeValidation *bool
	skipDuplicateCheck *bool
}

func (r ApiPostListsIdRequest) Body(body MembersToSubscribeUnsubscribeToFromAListInBatch) ApiPostListsIdRequest {
	r.body = &body
	return r
}

// If skip_merge_validation is true, member data will be accepted without merge field values, even if the merge field is usually required. This defaults to false.
func (r ApiPostListsIdRequest) SkipMergeValidation(skipMergeValidation bool) ApiPostListsIdRequest {
	r.skipMergeValidation = &skipMergeValidation
	return r
}

// If skip_duplicate_check is true, we will ignore duplicates sent in the request when using the batch sub/unsub on the lists endpoint. The status of the first appearance in the request will be saved. This defaults to false.
func (r ApiPostListsIdRequest) SkipDuplicateCheck(skipDuplicateCheck bool) ApiPostListsIdRequest {
	r.skipDuplicateCheck = &skipDuplicateCheck
	return r
}

func (r ApiPostListsIdRequest) Execute() (*BatchUpdateListMembers, *http.Response, error) {
	return r.ApiService.PostListsIdExecute(r)
}

/*
PostListsId Batch subscribe or unsubscribe

Batch subscribe or unsubscribe list members.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiPostListsIdRequest
*/
func (a *ListsAPIService) PostListsId(ctx context.Context, listId string) ApiPostListsIdRequest {
	return ApiPostListsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return BatchUpdateListMembers
func (a *ListsAPIService) PostListsIdExecute(r ApiPostListsIdRequest) (*BatchUpdateListMembers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchUpdateListMembers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.skipMergeValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_merge_validation", r.skipMergeValidation, "")
	}
	if r.skipDuplicateCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_duplicate_check", r.skipDuplicateCheck, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostListsIdInterestCategoriesRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	body *InterestCategory1
}

func (r ApiPostListsIdInterestCategoriesRequest) Body(body InterestCategory1) ApiPostListsIdInterestCategoriesRequest {
	r.body = &body
	return r
}

func (r ApiPostListsIdInterestCategoriesRequest) Execute() (*InterestCategory, *http.Response, error) {
	return r.ApiService.PostListsIdInterestCategoriesExecute(r)
}

/*
PostListsIdInterestCategories Add interest category

Create a new interest category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiPostListsIdInterestCategoriesRequest
*/
func (a *ListsAPIService) PostListsIdInterestCategories(ctx context.Context, listId string) ApiPostListsIdInterestCategoriesRequest {
	return ApiPostListsIdInterestCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return InterestCategory
func (a *ListsAPIService) PostListsIdInterestCategoriesExecute(r ApiPostListsIdInterestCategoriesRequest) (*InterestCategory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterestCategory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdInterestCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostListsIdInterestCategoriesIdInterestsRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	interestCategoryId string
	body *Interest1
}

func (r ApiPostListsIdInterestCategoriesIdInterestsRequest) Body(body Interest1) ApiPostListsIdInterestCategoriesIdInterestsRequest {
	r.body = &body
	return r
}

func (r ApiPostListsIdInterestCategoriesIdInterestsRequest) Execute() (*Interest, *http.Response, error) {
	return r.ApiService.PostListsIdInterestCategoriesIdInterestsExecute(r)
}

/*
PostListsIdInterestCategoriesIdInterests Add interest in category

Create a new interest or 'group name' for a specific category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param interestCategoryId The unique ID for the interest category.
 @return ApiPostListsIdInterestCategoriesIdInterestsRequest
*/
func (a *ListsAPIService) PostListsIdInterestCategoriesIdInterests(ctx context.Context, listId string, interestCategoryId string) ApiPostListsIdInterestCategoriesIdInterestsRequest {
	return ApiPostListsIdInterestCategoriesIdInterestsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		interestCategoryId: interestCategoryId,
	}
}

// Execute executes the request
//  @return Interest
func (a *ListsAPIService) PostListsIdInterestCategoriesIdInterestsExecute(r ApiPostListsIdInterestCategoriesIdInterestsRequest) (*Interest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdInterestCategoriesIdInterests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories/{interest_category_id}/interests"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_category_id"+"}", url.PathEscape(parameterValueToString(r.interestCategoryId, "interestCategoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostListsIdMembersRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	body *AddListMembers1
	skipMergeValidation *bool
}

func (r ApiPostListsIdMembersRequest) Body(body AddListMembers1) ApiPostListsIdMembersRequest {
	r.body = &body
	return r
}

// If skip_merge_validation is true, member data will be accepted without merge field values, even if the merge field is usually required. This defaults to false.
func (r ApiPostListsIdMembersRequest) SkipMergeValidation(skipMergeValidation bool) ApiPostListsIdMembersRequest {
	r.skipMergeValidation = &skipMergeValidation
	return r
}

func (r ApiPostListsIdMembersRequest) Execute() (*ListMembers2, *http.Response, error) {
	return r.ApiService.PostListsIdMembersExecute(r)
}

/*
PostListsIdMembers Add member to list

Add a new member to the list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiPostListsIdMembersRequest
*/
func (a *ListsAPIService) PostListsIdMembers(ctx context.Context, listId string) ApiPostListsIdMembersRequest {
	return ApiPostListsIdMembersRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return ListMembers2
func (a *ListsAPIService) PostListsIdMembersExecute(r ApiPostListsIdMembersRequest) (*ListMembers2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMembers2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdMembers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.skipMergeValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_merge_validation", r.skipMergeValidation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostListsIdMembersHashActionsDeletePermanentRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	subscriberHash string
}

func (r ApiPostListsIdMembersHashActionsDeletePermanentRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostListsIdMembersHashActionsDeletePermanentExecute(r)
}

/*
PostListsIdMembersHashActionsDeletePermanent Delete list member

Delete all personally identifiable information related to a list member, and remove them from a list. This will make it impossible to re-import the list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
 @return ApiPostListsIdMembersHashActionsDeletePermanentRequest
*/
func (a *ListsAPIService) PostListsIdMembersHashActionsDeletePermanent(ctx context.Context, listId string, subscriberHash string) ApiPostListsIdMembersHashActionsDeletePermanentRequest {
	return ApiPostListsIdMembersHashActionsDeletePermanentRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
func (a *ListsAPIService) PostListsIdMembersHashActionsDeletePermanentExecute(r ApiPostListsIdMembersHashActionsDeletePermanentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdMembersHashActionsDeletePermanent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/actions/delete-permanent"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostListsIdMembersIdNotesRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	subscriberHash string
	body *MemberNotes1
}

func (r ApiPostListsIdMembersIdNotesRequest) Body(body MemberNotes1) ApiPostListsIdMembersIdNotesRequest {
	r.body = &body
	return r
}

func (r ApiPostListsIdMembersIdNotesRequest) Execute() (*MemberNotes, *http.Response, error) {
	return r.ApiService.PostListsIdMembersIdNotesExecute(r)
}

/*
PostListsIdMembersIdNotes Add member note

Add a new note for a specific subscriber.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
 @return ApiPostListsIdMembersIdNotesRequest
*/
func (a *ListsAPIService) PostListsIdMembersIdNotes(ctx context.Context, listId string, subscriberHash string) ApiPostListsIdMembersIdNotesRequest {
	return ApiPostListsIdMembersIdNotesRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return MemberNotes
func (a *ListsAPIService) PostListsIdMembersIdNotesExecute(r ApiPostListsIdMembersIdNotesRequest) (*MemberNotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MemberNotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdMembersIdNotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/notes"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostListsIdMergeFieldsRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	body *MergeField1
}

func (r ApiPostListsIdMergeFieldsRequest) Body(body MergeField1) ApiPostListsIdMergeFieldsRequest {
	r.body = &body
	return r
}

func (r ApiPostListsIdMergeFieldsRequest) Execute() (*MergeField, *http.Response, error) {
	return r.ApiService.PostListsIdMergeFieldsExecute(r)
}

/*
PostListsIdMergeFields Add merge field

Add a new merge field for a specific audience.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiPostListsIdMergeFieldsRequest
*/
func (a *ListsAPIService) PostListsIdMergeFields(ctx context.Context, listId string) ApiPostListsIdMergeFieldsRequest {
	return ApiPostListsIdMergeFieldsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return MergeField
func (a *ListsAPIService) PostListsIdMergeFieldsExecute(r ApiPostListsIdMergeFieldsRequest) (*MergeField, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MergeField
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdMergeFields")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/merge-fields"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostListsIdSegmentsRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	body *List8
}

func (r ApiPostListsIdSegmentsRequest) Body(body List8) ApiPostListsIdSegmentsRequest {
	r.body = &body
	return r
}

func (r ApiPostListsIdSegmentsRequest) Execute() (*List7, *http.Response, error) {
	return r.ApiService.PostListsIdSegmentsExecute(r)
}

/*
PostListsIdSegments Add segment

Create a new segment in a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiPostListsIdSegmentsRequest
*/
func (a *ListsAPIService) PostListsIdSegments(ctx context.Context, listId string) ApiPostListsIdSegmentsRequest {
	return ApiPostListsIdSegmentsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return List7
func (a *ListsAPIService) PostListsIdSegmentsExecute(r ApiPostListsIdSegmentsRequest) (*List7, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *List7
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdSegments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostListsIdSegmentsIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	segmentId string
	body *MembersToAddRemoveToFromAStaticSegment
}

func (r ApiPostListsIdSegmentsIdRequest) Body(body MembersToAddRemoveToFromAStaticSegment) ApiPostListsIdSegmentsIdRequest {
	r.body = &body
	return r
}

func (r ApiPostListsIdSegmentsIdRequest) Execute() (*BatchAddRemoveListMembersToFromStaticSegment, *http.Response, error) {
	return r.ApiService.PostListsIdSegmentsIdExecute(r)
}

/*
PostListsIdSegmentsId Batch add or remove members

Batch add/remove list members to static segment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param segmentId The unique id for the segment.
 @return ApiPostListsIdSegmentsIdRequest
*/
func (a *ListsAPIService) PostListsIdSegmentsId(ctx context.Context, listId string, segmentId string) ApiPostListsIdSegmentsIdRequest {
	return ApiPostListsIdSegmentsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		segmentId: segmentId,
	}
}

// Execute executes the request
//  @return BatchAddRemoveListMembersToFromStaticSegment
func (a *ListsAPIService) PostListsIdSegmentsIdExecute(r ApiPostListsIdSegmentsIdRequest) (*BatchAddRemoveListMembersToFromStaticSegment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchAddRemoveListMembersToFromStaticSegment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdSegmentsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments/{segment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segment_id"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostListsIdSegmentsIdMembersRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	segmentId string
	body *PostListsIdSegmentsIdMembersRequest
}

func (r ApiPostListsIdSegmentsIdMembersRequest) Body(body PostListsIdSegmentsIdMembersRequest) ApiPostListsIdSegmentsIdMembersRequest {
	r.body = &body
	return r
}

func (r ApiPostListsIdSegmentsIdMembersRequest) Execute() (*ListMembers1, *http.Response, error) {
	return r.ApiService.PostListsIdSegmentsIdMembersExecute(r)
}

/*
PostListsIdSegmentsIdMembers Add member to segment

Add a member to a static segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param segmentId The unique id for the segment.
 @return ApiPostListsIdSegmentsIdMembersRequest
*/
func (a *ListsAPIService) PostListsIdSegmentsIdMembers(ctx context.Context, listId string, segmentId string) ApiPostListsIdSegmentsIdMembersRequest {
	return ApiPostListsIdSegmentsIdMembersRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		segmentId: segmentId,
	}
}

// Execute executes the request
//  @return ListMembers1
func (a *ListsAPIService) PostListsIdSegmentsIdMembersExecute(r ApiPostListsIdSegmentsIdMembersRequest) (*ListMembers1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMembers1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdSegmentsIdMembers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments/{segment_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segment_id"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostListsIdSignupFormsRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	body *SignupForm1
}

func (r ApiPostListsIdSignupFormsRequest) Body(body SignupForm1) ApiPostListsIdSignupFormsRequest {
	r.body = &body
	return r
}

func (r ApiPostListsIdSignupFormsRequest) Execute() (*SignupForm, *http.Response, error) {
	return r.ApiService.PostListsIdSignupFormsExecute(r)
}

/*
PostListsIdSignupForms Customize signup form

Customize a list's default signup form.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiPostListsIdSignupFormsRequest
*/
func (a *ListsAPIService) PostListsIdSignupForms(ctx context.Context, listId string) ApiPostListsIdSignupFormsRequest {
	return ApiPostListsIdSignupFormsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return SignupForm
func (a *ListsAPIService) PostListsIdSignupFormsExecute(r ApiPostListsIdSignupFormsRequest) (*SignupForm, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignupForm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdSignupForms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/signup-forms"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostListsIdWebhooksRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	body *AddWebhook
}

func (r ApiPostListsIdWebhooksRequest) Body(body AddWebhook) ApiPostListsIdWebhooksRequest {
	r.body = &body
	return r
}

func (r ApiPostListsIdWebhooksRequest) Execute() (*ListWebhooks, *http.Response, error) {
	return r.ApiService.PostListsIdWebhooksExecute(r)
}

/*
PostListsIdWebhooks Add webhook

Create a new webhook for a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiPostListsIdWebhooksRequest
*/
func (a *ListsAPIService) PostListsIdWebhooks(ctx context.Context, listId string) ApiPostListsIdWebhooksRequest {
	return ApiPostListsIdWebhooksRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return ListWebhooks
func (a *ListsAPIService) PostListsIdWebhooksExecute(r ApiPostListsIdWebhooksRequest) (*ListWebhooks, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListWebhooks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdWebhooks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/webhooks"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPreviewASegmentRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	type_ *string
	sinceCreatedAt *string
	beforeCreatedAt *string
	includeCleaned *bool
	includeTransactional *bool
	includeUnsubscribed *bool
	sinceUpdatedAt *string
	beforeUpdatedAt *string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiPreviewASegmentRequest) Fields(fields []string) ApiPreviewASegmentRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiPreviewASegmentRequest) ExcludeFields(excludeFields []string) ApiPreviewASegmentRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiPreviewASegmentRequest) Count(count int32) ApiPreviewASegmentRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiPreviewASegmentRequest) Offset(offset int32) ApiPreviewASegmentRequest {
	r.offset = &offset
	return r
}

// Limit results based on segment type.
func (r ApiPreviewASegmentRequest) Type_(type_ string) ApiPreviewASegmentRequest {
	r.type_ = &type_
	return r
}

// Restrict results to segments created after the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiPreviewASegmentRequest) SinceCreatedAt(sinceCreatedAt string) ApiPreviewASegmentRequest {
	r.sinceCreatedAt = &sinceCreatedAt
	return r
}

// Restrict results to segments created before the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiPreviewASegmentRequest) BeforeCreatedAt(beforeCreatedAt string) ApiPreviewASegmentRequest {
	r.beforeCreatedAt = &beforeCreatedAt
	return r
}

// Include cleaned members in response
func (r ApiPreviewASegmentRequest) IncludeCleaned(includeCleaned bool) ApiPreviewASegmentRequest {
	r.includeCleaned = &includeCleaned
	return r
}

// Include transactional members in response
func (r ApiPreviewASegmentRequest) IncludeTransactional(includeTransactional bool) ApiPreviewASegmentRequest {
	r.includeTransactional = &includeTransactional
	return r
}

// Include unsubscribed members in response
func (r ApiPreviewASegmentRequest) IncludeUnsubscribed(includeUnsubscribed bool) ApiPreviewASegmentRequest {
	r.includeUnsubscribed = &includeUnsubscribed
	return r
}

// Restrict results to segments update after the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiPreviewASegmentRequest) SinceUpdatedAt(sinceUpdatedAt string) ApiPreviewASegmentRequest {
	r.sinceUpdatedAt = &sinceUpdatedAt
	return r
}

// Restrict results to segments update before the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiPreviewASegmentRequest) BeforeUpdatedAt(beforeUpdatedAt string) ApiPreviewASegmentRequest {
	r.beforeUpdatedAt = &beforeUpdatedAt
	return r
}

func (r ApiPreviewASegmentRequest) Execute() (*CollectionOfSegments, *http.Response, error) {
	return r.ApiService.PreviewASegmentExecute(r)
}

/*
PreviewASegment List segments

Get information about all available segments for a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiPreviewASegmentRequest
*/
func (a *ListsAPIService) PreviewASegment(ctx context.Context, listId string) ApiPreviewASegmentRequest {
	return ApiPreviewASegmentRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return CollectionOfSegments
func (a *ListsAPIService) PreviewASegmentExecute(r ApiPreviewASegmentRequest) (*CollectionOfSegments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionOfSegments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PreviewASegment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.sinceCreatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_created_at", r.sinceCreatedAt, "")
	}
	if r.beforeCreatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_created_at", r.beforeCreatedAt, "")
	}
	if r.includeCleaned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_cleaned", r.includeCleaned, "")
	}
	if r.includeTransactional != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_transactional", r.includeTransactional, "")
	}
	if r.includeUnsubscribed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unsubscribed", r.includeUnsubscribed, "")
	}
	if r.sinceUpdatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_updated_at", r.sinceUpdatedAt, "")
	}
	if r.beforeUpdatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_updated_at", r.beforeUpdatedAt, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutListsIdMembersIdRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	subscriberHash string
	body *AddListMembers2
	skipMergeValidation *bool
}

func (r ApiPutListsIdMembersIdRequest) Body(body AddListMembers2) ApiPutListsIdMembersIdRequest {
	r.body = &body
	return r
}

// If skip_merge_validation is true, member data will be accepted without merge field values, even if the merge field is usually required. This defaults to false.
func (r ApiPutListsIdMembersIdRequest) SkipMergeValidation(skipMergeValidation bool) ApiPutListsIdMembersIdRequest {
	r.skipMergeValidation = &skipMergeValidation
	return r
}

func (r ApiPutListsIdMembersIdRequest) Execute() (*ListMembers2, *http.Response, error) {
	return r.ApiService.PutListsIdMembersIdExecute(r)
}

/*
PutListsIdMembersId Add or update list member

Add or update a list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ApiPutListsIdMembersIdRequest
*/
func (a *ListsAPIService) PutListsIdMembersId(ctx context.Context, listId string, subscriberHash string) ApiPutListsIdMembersIdRequest {
	return ApiPutListsIdMembersIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return ListMembers2
func (a *ListsAPIService) PutListsIdMembersIdExecute(r ApiPutListsIdMembersIdRequest) (*ListMembers2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMembers2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PutListsIdMembersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.skipMergeValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_merge_validation", r.skipMergeValidation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchTagsByNameRequest struct {
	ctx context.Context
	ApiService *ListsAPIService
	listId string
	name *string
}

// The search query used to filter tags.  The search query will be compared to each tag as a prefix, so all tags that have a name starting with this field will be returned.
func (r ApiSearchTagsByNameRequest) Name(name string) ApiSearchTagsByNameRequest {
	r.name = &name
	return r
}

func (r ApiSearchTagsByNameRequest) Execute() (*TagSearchResults, *http.Response, error) {
	return r.ApiService.SearchTagsByNameExecute(r)
}

/*
SearchTagsByName Search for tags on a list by name.

Search for tags on a list by name. If no name is provided, will return all tags on the list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ApiSearchTagsByNameRequest
*/
func (a *ListsAPIService) SearchTagsByName(ctx context.Context, listId string) ApiSearchTagsByNameRequest {
	return ApiSearchTagsByNameRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return TagSearchResults
func (a *ListsAPIService) SearchTagsByNameExecute(r ApiSearchTagsByNameRequest) (*TagSearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.SearchTagsByName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/tag-search"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
