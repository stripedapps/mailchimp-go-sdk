/*
Mailchimp Marketing API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.0.55
Contact: apihelp@mailchimp.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// ConversationsAPIService ConversationsAPI service
type ConversationsAPIService service

type ApiGetConversationsRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	hasUnreadMessages *string
	listId *string
	campaignId *string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetConversationsRequest) Fields(fields []string) ApiGetConversationsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetConversationsRequest) ExcludeFields(excludeFields []string) ApiGetConversationsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetConversationsRequest) Count(count int32) ApiGetConversationsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetConversationsRequest) Offset(offset int32) ApiGetConversationsRequest {
	r.offset = &offset
	return r
}

// Whether the conversation has any unread messages.
func (r ApiGetConversationsRequest) HasUnreadMessages(hasUnreadMessages string) ApiGetConversationsRequest {
	r.hasUnreadMessages = &hasUnreadMessages
	return r
}

// The unique id for the list.
func (r ApiGetConversationsRequest) ListId(listId string) ApiGetConversationsRequest {
	r.listId = &listId
	return r
}

// The unique id for the campaign.
func (r ApiGetConversationsRequest) CampaignId(campaignId string) ApiGetConversationsRequest {
	r.campaignId = &campaignId
	return r
}

func (r ApiGetConversationsRequest) Execute() (*TrackedConversations, *http.Response, error) {
	return r.ApiService.GetConversationsExecute(r)
}

/*
GetConversations List conversations

Get a list of conversations for the account. Conversations has been deprecated in favor of Inbox and these endpoints don't include Inbox data. Past Conversations are still available via this endpoint, but new campaign replies and other Inbox messages aren’t available using this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConversationsRequest

Deprecated
*/
func (a *ConversationsAPIService) GetConversations(ctx context.Context) ApiGetConversationsRequest {
	return ApiGetConversationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TrackedConversations
// Deprecated
func (a *ConversationsAPIService) GetConversationsExecute(r ApiGetConversationsRequest) (*TrackedConversations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackedConversations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.hasUnreadMessages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_unread_messages", r.hasUnreadMessages, "")
	}
	if r.listId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "list_id", r.listId, "")
	}
	if r.campaignId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "campaign_id", r.campaignId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversationsIdRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	conversationId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetConversationsIdRequest) Fields(fields []string) ApiGetConversationsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetConversationsIdRequest) ExcludeFields(excludeFields []string) ApiGetConversationsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetConversationsIdRequest) Execute() (*Conversation, *http.Response, error) {
	return r.ApiService.GetConversationsIdExecute(r)
}

/*
GetConversationsId Get conversation

Get details about an individual conversation. Conversations has been deprecated in favor of Inbox and these endpoints don't include Inbox data. Past Conversations are still available via this endpoint, but new campaign replies and other Inbox messages aren’t available using this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId The unique id for the conversation.
 @return ApiGetConversationsIdRequest

Deprecated
*/
func (a *ConversationsAPIService) GetConversationsId(ctx context.Context, conversationId string) ApiGetConversationsIdRequest {
	return ApiGetConversationsIdRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return Conversation
// Deprecated
func (a *ConversationsAPIService) GetConversationsIdExecute(r ApiGetConversationsIdRequest) (*Conversation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Conversation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/{conversation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversationsIdMessagesRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	conversationId string
	fields *[]string
	excludeFields *[]string
	isRead *string
	beforeTimestamp *time.Time
	sinceTimestamp *time.Time
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetConversationsIdMessagesRequest) Fields(fields []string) ApiGetConversationsIdMessagesRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetConversationsIdMessagesRequest) ExcludeFields(excludeFields []string) ApiGetConversationsIdMessagesRequest {
	r.excludeFields = &excludeFields
	return r
}

// Whether a conversation message has been marked as read.
func (r ApiGetConversationsIdMessagesRequest) IsRead(isRead string) ApiGetConversationsIdMessagesRequest {
	r.isRead = &isRead
	return r
}

// Restrict the response to messages created before the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiGetConversationsIdMessagesRequest) BeforeTimestamp(beforeTimestamp time.Time) ApiGetConversationsIdMessagesRequest {
	r.beforeTimestamp = &beforeTimestamp
	return r
}

// Restrict the response to messages created after the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiGetConversationsIdMessagesRequest) SinceTimestamp(sinceTimestamp time.Time) ApiGetConversationsIdMessagesRequest {
	r.sinceTimestamp = &sinceTimestamp
	return r
}

func (r ApiGetConversationsIdMessagesRequest) Execute() (*CollectionOfConversationMessages, *http.Response, error) {
	return r.ApiService.GetConversationsIdMessagesExecute(r)
}

/*
GetConversationsIdMessages List messages

Get messages from a specific conversation. Conversations has been deprecated in favor of Inbox and these endpoints don't include Inbox data. Past Conversations are still available via this endpoint, but new campaign replies and other Inbox messages aren’t available using this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId The unique id for the conversation.
 @return ApiGetConversationsIdMessagesRequest

Deprecated
*/
func (a *ConversationsAPIService) GetConversationsIdMessages(ctx context.Context, conversationId string) ApiGetConversationsIdMessagesRequest {
	return ApiGetConversationsIdMessagesRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return CollectionOfConversationMessages
// Deprecated
func (a *ConversationsAPIService) GetConversationsIdMessagesExecute(r ApiGetConversationsIdMessagesRequest) (*CollectionOfConversationMessages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionOfConversationMessages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsIdMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/{conversation_id}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.isRead != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_read", r.isRead, "")
	}
	if r.beforeTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_timestamp", r.beforeTimestamp, "")
	}
	if r.sinceTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_timestamp", r.sinceTimestamp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversationsIdMessagesIdRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	conversationId string
	messageId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetConversationsIdMessagesIdRequest) Fields(fields []string) ApiGetConversationsIdMessagesIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetConversationsIdMessagesIdRequest) ExcludeFields(excludeFields []string) ApiGetConversationsIdMessagesIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetConversationsIdMessagesIdRequest) Execute() (*ConversationMessage, *http.Response, error) {
	return r.ApiService.GetConversationsIdMessagesIdExecute(r)
}

/*
GetConversationsIdMessagesId Get message

Get an individual message in a conversation. Conversations has been deprecated in favor of Inbox and these endpoints don't include Inbox data. Past Conversations are still available via this endpoint, but new campaign replies and other Inbox messages aren’t available using this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId The unique id for the conversation.
 @param messageId The unique id for the conversation message.
 @return ApiGetConversationsIdMessagesIdRequest

Deprecated
*/
func (a *ConversationsAPIService) GetConversationsIdMessagesId(ctx context.Context, conversationId string, messageId string) ApiGetConversationsIdMessagesIdRequest {
	return ApiGetConversationsIdMessagesIdRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return ConversationMessage
// Deprecated
func (a *ConversationsAPIService) GetConversationsIdMessagesIdExecute(r ApiGetConversationsIdMessagesIdRequest) (*ConversationMessage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsIdMessagesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/{conversation_id}/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
