/*
Mailchimp Marketing API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.0.55
Contact: apihelp@mailchimp.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// AutomationsAPIService AutomationsAPI service
type AutomationsAPIService service

type ApiArchiveAutomationsRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	workflowId string
}

func (r ApiArchiveAutomationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveAutomationsExecute(r)
}

/*
ArchiveAutomations Archive automation

Archiving will permanently end your automation and keep the report data. You’ll be able to replicate your archived automation, but you can’t restart it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @return ApiArchiveAutomationsRequest
*/
func (a *AutomationsAPIService) ArchiveAutomations(ctx context.Context, workflowId string) ApiArchiveAutomationsRequest {
	return ApiArchiveAutomationsRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
	}
}

// Execute executes the request
func (a *AutomationsAPIService) ArchiveAutomationsExecute(r ApiArchiveAutomationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.ArchiveAutomations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/actions/archive"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAutomationsIdEmailsIdRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	workflowId string
	workflowEmailId string
}

func (r ApiDeleteAutomationsIdEmailsIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAutomationsIdEmailsIdExecute(r)
}

/*
DeleteAutomationsIdEmailsId Delete workflow email

Removes an individual classic automation workflow email. Emails from certain workflow types, including the Abandoned Cart Email (abandonedCart) and Product Retargeting Email (abandonedBrowse) Workflows, cannot be deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param workflowEmailId The unique id for the Automation workflow email.
 @return ApiDeleteAutomationsIdEmailsIdRequest
*/
func (a *AutomationsAPIService) DeleteAutomationsIdEmailsId(ctx context.Context, workflowId string, workflowEmailId string) ApiDeleteAutomationsIdEmailsIdRequest {
	return ApiDeleteAutomationsIdEmailsIdRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowEmailId: workflowEmailId,
	}
}

// Execute executes the request
func (a *AutomationsAPIService) DeleteAutomationsIdEmailsIdExecute(r ApiDeleteAutomationsIdEmailsIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.DeleteAutomationsIdEmailsId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails/{workflow_email_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_email_id"+"}", url.PathEscape(parameterValueToString(r.workflowEmailId, "workflowEmailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAutomationsRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	count *int32
	offset *int32
	fields *[]string
	excludeFields *[]string
	beforeCreateTime *time.Time
	sinceCreateTime *time.Time
	beforeStartTime *time.Time
	sinceStartTime *time.Time
	status *string
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetAutomationsRequest) Count(count int32) ApiGetAutomationsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetAutomationsRequest) Offset(offset int32) ApiGetAutomationsRequest {
	r.offset = &offset
	return r
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetAutomationsRequest) Fields(fields []string) ApiGetAutomationsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetAutomationsRequest) ExcludeFields(excludeFields []string) ApiGetAutomationsRequest {
	r.excludeFields = &excludeFields
	return r
}

// Restrict the response to automations created before this time. Uses the ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiGetAutomationsRequest) BeforeCreateTime(beforeCreateTime time.Time) ApiGetAutomationsRequest {
	r.beforeCreateTime = &beforeCreateTime
	return r
}

// Restrict the response to automations created after this time. Uses the ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiGetAutomationsRequest) SinceCreateTime(sinceCreateTime time.Time) ApiGetAutomationsRequest {
	r.sinceCreateTime = &sinceCreateTime
	return r
}

// Restrict the response to automations started before this time. Uses the ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiGetAutomationsRequest) BeforeStartTime(beforeStartTime time.Time) ApiGetAutomationsRequest {
	r.beforeStartTime = &beforeStartTime
	return r
}

// Restrict the response to automations started after this time. Uses the ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ApiGetAutomationsRequest) SinceStartTime(sinceStartTime time.Time) ApiGetAutomationsRequest {
	r.sinceStartTime = &sinceStartTime
	return r
}

// Restrict the results to automations with the specified status.
func (r ApiGetAutomationsRequest) Status(status string) ApiGetAutomationsRequest {
	r.status = &status
	return r
}

func (r ApiGetAutomationsRequest) Execute() (*GetAutomations200Response, *http.Response, error) {
	return r.ApiService.GetAutomationsExecute(r)
}

/*
GetAutomations List automations

Get a summary of an account's classic automations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAutomationsRequest
*/
func (a *AutomationsAPIService) GetAutomations(ctx context.Context) ApiGetAutomationsRequest {
	return ApiGetAutomationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAutomations200Response
func (a *AutomationsAPIService) GetAutomationsExecute(r ApiGetAutomationsRequest) (*GetAutomations200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAutomations200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.GetAutomations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.beforeCreateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_create_time", r.beforeCreateTime, "")
	}
	if r.sinceCreateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_create_time", r.sinceCreateTime, "")
	}
	if r.beforeStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_start_time", r.beforeStartTime, "")
	}
	if r.sinceStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_start_time", r.sinceStartTime, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAutomationsIdRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	workflowId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetAutomationsIdRequest) Fields(fields []string) ApiGetAutomationsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetAutomationsIdRequest) ExcludeFields(excludeFields []string) ApiGetAutomationsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetAutomationsIdRequest) Execute() (*AutomationWorkflow, *http.Response, error) {
	return r.ApiService.GetAutomationsIdExecute(r)
}

/*
GetAutomationsId Get automation info

Get a summary of an individual classic automation workflow's settings and content. The `trigger_settings` object returns information for the first email in the workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @return ApiGetAutomationsIdRequest
*/
func (a *AutomationsAPIService) GetAutomationsId(ctx context.Context, workflowId string) ApiGetAutomationsIdRequest {
	return ApiGetAutomationsIdRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
	}
}

// Execute executes the request
//  @return AutomationWorkflow
func (a *AutomationsAPIService) GetAutomationsIdExecute(r ApiGetAutomationsIdRequest) (*AutomationWorkflow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutomationWorkflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.GetAutomationsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAutomationsIdEmailsRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	workflowId string
}

func (r ApiGetAutomationsIdEmailsRequest) Execute() (*AutomationEmails, *http.Response, error) {
	return r.ApiService.GetAutomationsIdEmailsExecute(r)
}

/*
GetAutomationsIdEmails List automated emails

Get a summary of the emails in a classic automation workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @return ApiGetAutomationsIdEmailsRequest
*/
func (a *AutomationsAPIService) GetAutomationsIdEmails(ctx context.Context, workflowId string) ApiGetAutomationsIdEmailsRequest {
	return ApiGetAutomationsIdEmailsRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
	}
}

// Execute executes the request
//  @return AutomationEmails
func (a *AutomationsAPIService) GetAutomationsIdEmailsExecute(r ApiGetAutomationsIdEmailsRequest) (*AutomationEmails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutomationEmails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.GetAutomationsIdEmails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAutomationsIdEmailsIdRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	workflowId string
	workflowEmailId string
}

func (r ApiGetAutomationsIdEmailsIdRequest) Execute() (*AutomationWorkflowEmail, *http.Response, error) {
	return r.ApiService.GetAutomationsIdEmailsIdExecute(r)
}

/*
GetAutomationsIdEmailsId Get workflow email info

Get information about an individual classic automation workflow email.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param workflowEmailId The unique id for the Automation workflow email.
 @return ApiGetAutomationsIdEmailsIdRequest
*/
func (a *AutomationsAPIService) GetAutomationsIdEmailsId(ctx context.Context, workflowId string, workflowEmailId string) ApiGetAutomationsIdEmailsIdRequest {
	return ApiGetAutomationsIdEmailsIdRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowEmailId: workflowEmailId,
	}
}

// Execute executes the request
//  @return AutomationWorkflowEmail
func (a *AutomationsAPIService) GetAutomationsIdEmailsIdExecute(r ApiGetAutomationsIdEmailsIdRequest) (*AutomationWorkflowEmail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutomationWorkflowEmail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.GetAutomationsIdEmailsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails/{workflow_email_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_email_id"+"}", url.PathEscape(parameterValueToString(r.workflowEmailId, "workflowEmailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAutomationsIdEmailsIdQueueRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	workflowId string
	workflowEmailId string
}

func (r ApiGetAutomationsIdEmailsIdQueueRequest) Execute() (*GetAutomationsIdEmailsIdQueue200Response, *http.Response, error) {
	return r.ApiService.GetAutomationsIdEmailsIdQueueExecute(r)
}

/*
GetAutomationsIdEmailsIdQueue List automated email subscribers

Get information about a classic automation email queue.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param workflowEmailId The unique id for the Automation workflow email.
 @return ApiGetAutomationsIdEmailsIdQueueRequest
*/
func (a *AutomationsAPIService) GetAutomationsIdEmailsIdQueue(ctx context.Context, workflowId string, workflowEmailId string) ApiGetAutomationsIdEmailsIdQueueRequest {
	return ApiGetAutomationsIdEmailsIdQueueRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowEmailId: workflowEmailId,
	}
}

// Execute executes the request
//  @return GetAutomationsIdEmailsIdQueue200Response
func (a *AutomationsAPIService) GetAutomationsIdEmailsIdQueueExecute(r ApiGetAutomationsIdEmailsIdQueueRequest) (*GetAutomationsIdEmailsIdQueue200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAutomationsIdEmailsIdQueue200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.GetAutomationsIdEmailsIdQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails/{workflow_email_id}/queue"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_email_id"+"}", url.PathEscape(parameterValueToString(r.workflowEmailId, "workflowEmailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAutomationsIdEmailsIdQueueIdRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	workflowId string
	workflowEmailId string
	subscriberHash string
}

func (r ApiGetAutomationsIdEmailsIdQueueIdRequest) Execute() (*SubscriberInAutomationQueue2, *http.Response, error) {
	return r.ApiService.GetAutomationsIdEmailsIdQueueIdExecute(r)
}

/*
GetAutomationsIdEmailsIdQueueId Get automated email subscriber

Get information about a specific subscriber in a classic automation email queue.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param workflowEmailId The unique id for the Automation workflow email.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
 @return ApiGetAutomationsIdEmailsIdQueueIdRequest
*/
func (a *AutomationsAPIService) GetAutomationsIdEmailsIdQueueId(ctx context.Context, workflowId string, workflowEmailId string, subscriberHash string) ApiGetAutomationsIdEmailsIdQueueIdRequest {
	return ApiGetAutomationsIdEmailsIdQueueIdRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowEmailId: workflowEmailId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return SubscriberInAutomationQueue2
func (a *AutomationsAPIService) GetAutomationsIdEmailsIdQueueIdExecute(r ApiGetAutomationsIdEmailsIdQueueIdRequest) (*SubscriberInAutomationQueue2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriberInAutomationQueue2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.GetAutomationsIdEmailsIdQueueId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails/{workflow_email_id}/queue/{subscriber_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_email_id"+"}", url.PathEscape(parameterValueToString(r.workflowEmailId, "workflowEmailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAutomationsIdRemovedSubscribersRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	workflowId string
}

func (r ApiGetAutomationsIdRemovedSubscribersRequest) Execute() (*RemovedSubscribers, *http.Response, error) {
	return r.ApiService.GetAutomationsIdRemovedSubscribersExecute(r)
}

/*
GetAutomationsIdRemovedSubscribers List subscribers removed from workflow

Get information about subscribers who were removed from a classic automation workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @return ApiGetAutomationsIdRemovedSubscribersRequest
*/
func (a *AutomationsAPIService) GetAutomationsIdRemovedSubscribers(ctx context.Context, workflowId string) ApiGetAutomationsIdRemovedSubscribersRequest {
	return ApiGetAutomationsIdRemovedSubscribersRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
	}
}

// Execute executes the request
//  @return RemovedSubscribers
func (a *AutomationsAPIService) GetAutomationsIdRemovedSubscribersExecute(r ApiGetAutomationsIdRemovedSubscribersRequest) (*RemovedSubscribers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemovedSubscribers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.GetAutomationsIdRemovedSubscribers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/removed-subscribers"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAutomationsIdRemovedSubscribersIdRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	workflowId string
	subscriberHash string
}

func (r ApiGetAutomationsIdRemovedSubscribersIdRequest) Execute() (*SubscriberRemovedFromAutomationWorkflow, *http.Response, error) {
	return r.ApiService.GetAutomationsIdRemovedSubscribersIdExecute(r)
}

/*
GetAutomationsIdRemovedSubscribersId Get subscriber removed from workflow

Get information about a specific subscriber who was removed from a classic automation workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
 @return ApiGetAutomationsIdRemovedSubscribersIdRequest
*/
func (a *AutomationsAPIService) GetAutomationsIdRemovedSubscribersId(ctx context.Context, workflowId string, subscriberHash string) ApiGetAutomationsIdRemovedSubscribersIdRequest {
	return ApiGetAutomationsIdRemovedSubscribersIdRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return SubscriberRemovedFromAutomationWorkflow
func (a *AutomationsAPIService) GetAutomationsIdRemovedSubscribersIdExecute(r ApiGetAutomationsIdRemovedSubscribersIdRequest) (*SubscriberRemovedFromAutomationWorkflow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriberRemovedFromAutomationWorkflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.GetAutomationsIdRemovedSubscribersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/removed-subscribers/{subscriber_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchAutomationEmailWorkflowIdRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	workflowId string
	workflowEmailId string
	body *UpdateInformationAboutASpecificWorkflowEmail
}

func (r ApiPatchAutomationEmailWorkflowIdRequest) Body(body UpdateInformationAboutASpecificWorkflowEmail) ApiPatchAutomationEmailWorkflowIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchAutomationEmailWorkflowIdRequest) Execute() (*AutomationWorkflowEmail, *http.Response, error) {
	return r.ApiService.PatchAutomationEmailWorkflowIdExecute(r)
}

/*
PatchAutomationEmailWorkflowId Update workflow email

Update settings for a classic automation workflow email.  Only works with workflows of type: abandonedBrowse, abandonedCart, emailFollowup, or singleWelcome.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param workflowEmailId The unique id for the Automation workflow email.
 @return ApiPatchAutomationEmailWorkflowIdRequest
*/
func (a *AutomationsAPIService) PatchAutomationEmailWorkflowId(ctx context.Context, workflowId string, workflowEmailId string) ApiPatchAutomationEmailWorkflowIdRequest {
	return ApiPatchAutomationEmailWorkflowIdRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowEmailId: workflowEmailId,
	}
}

// Execute executes the request
//  @return AutomationWorkflowEmail
func (a *AutomationsAPIService) PatchAutomationEmailWorkflowIdExecute(r ApiPatchAutomationEmailWorkflowIdRequest) (*AutomationWorkflowEmail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutomationWorkflowEmail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.PatchAutomationEmailWorkflowId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails/{workflow_email_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_email_id"+"}", url.PathEscape(parameterValueToString(r.workflowEmailId, "workflowEmailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAutomationsRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	body *AutomationWorkflow1
}

func (r ApiPostAutomationsRequest) Body(body AutomationWorkflow1) ApiPostAutomationsRequest {
	r.body = &body
	return r
}

func (r ApiPostAutomationsRequest) Execute() (*AutomationWorkflow, *http.Response, error) {
	return r.ApiService.PostAutomationsExecute(r)
}

/*
PostAutomations Add automation

Create a new classic automation in your Mailchimp account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostAutomationsRequest
*/
func (a *AutomationsAPIService) PostAutomations(ctx context.Context) ApiPostAutomationsRequest {
	return ApiPostAutomationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AutomationWorkflow
func (a *AutomationsAPIService) PostAutomationsExecute(r ApiPostAutomationsRequest) (*AutomationWorkflow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutomationWorkflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.PostAutomations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAutomationsIdActionsPauseAllEmailsRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	workflowId string
}

func (r ApiPostAutomationsIdActionsPauseAllEmailsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostAutomationsIdActionsPauseAllEmailsExecute(r)
}

/*
PostAutomationsIdActionsPauseAllEmails Pause automation emails

Pause all emails in a specific classic automation workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @return ApiPostAutomationsIdActionsPauseAllEmailsRequest
*/
func (a *AutomationsAPIService) PostAutomationsIdActionsPauseAllEmails(ctx context.Context, workflowId string) ApiPostAutomationsIdActionsPauseAllEmailsRequest {
	return ApiPostAutomationsIdActionsPauseAllEmailsRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
	}
}

// Execute executes the request
func (a *AutomationsAPIService) PostAutomationsIdActionsPauseAllEmailsExecute(r ApiPostAutomationsIdActionsPauseAllEmailsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.PostAutomationsIdActionsPauseAllEmails")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/actions/pause-all-emails"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostAutomationsIdActionsStartAllEmailsRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	workflowId string
}

func (r ApiPostAutomationsIdActionsStartAllEmailsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostAutomationsIdActionsStartAllEmailsExecute(r)
}

/*
PostAutomationsIdActionsStartAllEmails Start automation emails

Start all emails in a classic automation workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @return ApiPostAutomationsIdActionsStartAllEmailsRequest
*/
func (a *AutomationsAPIService) PostAutomationsIdActionsStartAllEmails(ctx context.Context, workflowId string) ApiPostAutomationsIdActionsStartAllEmailsRequest {
	return ApiPostAutomationsIdActionsStartAllEmailsRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
	}
}

// Execute executes the request
func (a *AutomationsAPIService) PostAutomationsIdActionsStartAllEmailsExecute(r ApiPostAutomationsIdActionsStartAllEmailsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.PostAutomationsIdActionsStartAllEmails")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/actions/start-all-emails"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostAutomationsIdEmailsIdActionsPauseRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	workflowId string
	workflowEmailId string
}

func (r ApiPostAutomationsIdEmailsIdActionsPauseRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostAutomationsIdEmailsIdActionsPauseExecute(r)
}

/*
PostAutomationsIdEmailsIdActionsPause Pause automated email

Pause an automated email.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param workflowEmailId The unique id for the Automation workflow email.
 @return ApiPostAutomationsIdEmailsIdActionsPauseRequest
*/
func (a *AutomationsAPIService) PostAutomationsIdEmailsIdActionsPause(ctx context.Context, workflowId string, workflowEmailId string) ApiPostAutomationsIdEmailsIdActionsPauseRequest {
	return ApiPostAutomationsIdEmailsIdActionsPauseRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowEmailId: workflowEmailId,
	}
}

// Execute executes the request
func (a *AutomationsAPIService) PostAutomationsIdEmailsIdActionsPauseExecute(r ApiPostAutomationsIdEmailsIdActionsPauseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.PostAutomationsIdEmailsIdActionsPause")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails/{workflow_email_id}/actions/pause"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_email_id"+"}", url.PathEscape(parameterValueToString(r.workflowEmailId, "workflowEmailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostAutomationsIdEmailsIdActionsStartRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	workflowId string
	workflowEmailId string
}

func (r ApiPostAutomationsIdEmailsIdActionsStartRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostAutomationsIdEmailsIdActionsStartExecute(r)
}

/*
PostAutomationsIdEmailsIdActionsStart Start automated email

Start an automated email.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param workflowEmailId The unique id for the Automation workflow email.
 @return ApiPostAutomationsIdEmailsIdActionsStartRequest
*/
func (a *AutomationsAPIService) PostAutomationsIdEmailsIdActionsStart(ctx context.Context, workflowId string, workflowEmailId string) ApiPostAutomationsIdEmailsIdActionsStartRequest {
	return ApiPostAutomationsIdEmailsIdActionsStartRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowEmailId: workflowEmailId,
	}
}

// Execute executes the request
func (a *AutomationsAPIService) PostAutomationsIdEmailsIdActionsStartExecute(r ApiPostAutomationsIdEmailsIdActionsStartRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.PostAutomationsIdEmailsIdActionsStart")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails/{workflow_email_id}/actions/start"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_email_id"+"}", url.PathEscape(parameterValueToString(r.workflowEmailId, "workflowEmailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostAutomationsIdEmailsIdQueueRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	workflowId string
	workflowEmailId string
	body *SubscriberInAutomationQueue1
}

func (r ApiPostAutomationsIdEmailsIdQueueRequest) Body(body SubscriberInAutomationQueue1) ApiPostAutomationsIdEmailsIdQueueRequest {
	r.body = &body
	return r
}

func (r ApiPostAutomationsIdEmailsIdQueueRequest) Execute() (*SubscriberInAutomationQueue2, *http.Response, error) {
	return r.ApiService.PostAutomationsIdEmailsIdQueueExecute(r)
}

/*
PostAutomationsIdEmailsIdQueue Add subscriber to workflow email

Manually add a subscriber to a workflow, bypassing the default trigger settings. You can also use this endpoint to trigger a series of automated emails in an API 3.0 workflow type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param workflowEmailId The unique id for the Automation workflow email.
 @return ApiPostAutomationsIdEmailsIdQueueRequest
*/
func (a *AutomationsAPIService) PostAutomationsIdEmailsIdQueue(ctx context.Context, workflowId string, workflowEmailId string) ApiPostAutomationsIdEmailsIdQueueRequest {
	return ApiPostAutomationsIdEmailsIdQueueRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowEmailId: workflowEmailId,
	}
}

// Execute executes the request
//  @return SubscriberInAutomationQueue2
func (a *AutomationsAPIService) PostAutomationsIdEmailsIdQueueExecute(r ApiPostAutomationsIdEmailsIdQueueRequest) (*SubscriberInAutomationQueue2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriberInAutomationQueue2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.PostAutomationsIdEmailsIdQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails/{workflow_email_id}/queue"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_email_id"+"}", url.PathEscape(parameterValueToString(r.workflowEmailId, "workflowEmailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAutomationsIdRemovedSubscribersRequest struct {
	ctx context.Context
	ApiService *AutomationsAPIService
	workflowId string
	body *SubscriberInAutomationQueue1
}

func (r ApiPostAutomationsIdRemovedSubscribersRequest) Body(body SubscriberInAutomationQueue1) ApiPostAutomationsIdRemovedSubscribersRequest {
	r.body = &body
	return r
}

func (r ApiPostAutomationsIdRemovedSubscribersRequest) Execute() (*SubscriberRemovedFromAutomationWorkflow, *http.Response, error) {
	return r.ApiService.PostAutomationsIdRemovedSubscribersExecute(r)
}

/*
PostAutomationsIdRemovedSubscribers Remove subscriber from workflow

Remove a subscriber from a specific classic automation workflow. You can remove a subscriber at any point in an automation workflow, regardless of how many emails they've been sent from that workflow. Once they're removed, they can never be added back to the same workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @return ApiPostAutomationsIdRemovedSubscribersRequest
*/
func (a *AutomationsAPIService) PostAutomationsIdRemovedSubscribers(ctx context.Context, workflowId string) ApiPostAutomationsIdRemovedSubscribersRequest {
	return ApiPostAutomationsIdRemovedSubscribersRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
	}
}

// Execute executes the request
//  @return SubscriberRemovedFromAutomationWorkflow
func (a *AutomationsAPIService) PostAutomationsIdRemovedSubscribersExecute(r ApiPostAutomationsIdRemovedSubscribersRequest) (*SubscriberRemovedFromAutomationWorkflow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriberRemovedFromAutomationWorkflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.PostAutomationsIdRemovedSubscribers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/removed-subscribers"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
