/*
Mailchimp Marketing API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.0.55
Contact: apihelp@mailchimp.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// EcommerceAPIService EcommerceAPI service
type EcommerceAPIService service

type ApiDeleteEcommerceStoresIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
}

func (r ApiDeleteEcommerceStoresIdRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdExecute(r)
}

/*
DeleteEcommerceStoresId Delete store

Delete a store. Deleting a store will also delete any associated subresources, including Customers, Orders, Products, and Carts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return ApiDeleteEcommerceStoresIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresId(ctx context.Context, storeId string) ApiDeleteEcommerceStoresIdRequest {
	return ApiDeleteEcommerceStoresIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *EcommerceAPIService) DeleteEcommerceStoresIdExecute(r ApiDeleteEcommerceStoresIdRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteEcommerceStoresIdCartsIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	cartId string
}

func (r ApiDeleteEcommerceStoresIdCartsIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdCartsIdExecute(r)
}

/*
DeleteEcommerceStoresIdCartsId Delete cart

Delete a cart.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param cartId The id for the cart.
 @return ApiDeleteEcommerceStoresIdCartsIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdCartsId(ctx context.Context, storeId string, cartId string) ApiDeleteEcommerceStoresIdCartsIdRequest {
	return ApiDeleteEcommerceStoresIdCartsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		cartId: cartId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdCartsIdExecute(r ApiDeleteEcommerceStoresIdCartsIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdCartsId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts/{cart_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cart_id"+"}", url.PathEscape(parameterValueToString(r.cartId, "cartId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteEcommerceStoresIdCartsLinesIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	cartId string
	lineId string
}

func (r ApiDeleteEcommerceStoresIdCartsLinesIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdCartsLinesIdExecute(r)
}

/*
DeleteEcommerceStoresIdCartsLinesId Delete cart line item

Delete a specific cart line item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param cartId The id for the cart.
 @param lineId The id for the line item of a cart.
 @return ApiDeleteEcommerceStoresIdCartsLinesIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdCartsLinesId(ctx context.Context, storeId string, cartId string, lineId string) ApiDeleteEcommerceStoresIdCartsLinesIdRequest {
	return ApiDeleteEcommerceStoresIdCartsLinesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		cartId: cartId,
		lineId: lineId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdCartsLinesIdExecute(r ApiDeleteEcommerceStoresIdCartsLinesIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdCartsLinesId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts/{cart_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cart_id"+"}", url.PathEscape(parameterValueToString(r.cartId, "cartId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteEcommerceStoresIdCustomersIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	customerId string
}

func (r ApiDeleteEcommerceStoresIdCustomersIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdCustomersIdExecute(r)
}

/*
DeleteEcommerceStoresIdCustomersId Delete customer

Delete a customer from a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param customerId The id for the customer of a store.
 @return ApiDeleteEcommerceStoresIdCustomersIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdCustomersId(ctx context.Context, storeId string, customerId string) ApiDeleteEcommerceStoresIdCustomersIdRequest {
	return ApiDeleteEcommerceStoresIdCustomersIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		customerId: customerId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdCustomersIdExecute(r ApiDeleteEcommerceStoresIdCustomersIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdCustomersId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/customers/{customer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customer_id"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteEcommerceStoresIdOrdersIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	orderId string
}

func (r ApiDeleteEcommerceStoresIdOrdersIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdOrdersIdExecute(r)
}

/*
DeleteEcommerceStoresIdOrdersId Delete order

Delete an order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param orderId The id for the order in a store.
 @return ApiDeleteEcommerceStoresIdOrdersIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdOrdersId(ctx context.Context, storeId string, orderId string) ApiDeleteEcommerceStoresIdOrdersIdRequest {
	return ApiDeleteEcommerceStoresIdOrdersIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		orderId: orderId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdOrdersIdExecute(r ApiDeleteEcommerceStoresIdOrdersIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdOrdersId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders/{order_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteEcommerceStoresIdOrdersIdLinesIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	orderId string
	lineId string
}

func (r ApiDeleteEcommerceStoresIdOrdersIdLinesIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdOrdersIdLinesIdExecute(r)
}

/*
DeleteEcommerceStoresIdOrdersIdLinesId Delete order line item

Delete a specific order line item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param orderId The id for the order in a store.
 @param lineId The id for the line item of an order.
 @return ApiDeleteEcommerceStoresIdOrdersIdLinesIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdOrdersIdLinesId(ctx context.Context, storeId string, orderId string, lineId string) ApiDeleteEcommerceStoresIdOrdersIdLinesIdRequest {
	return ApiDeleteEcommerceStoresIdOrdersIdLinesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		orderId: orderId,
		lineId: lineId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdOrdersIdLinesIdExecute(r ApiDeleteEcommerceStoresIdOrdersIdLinesIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdOrdersIdLinesId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders/{order_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteEcommerceStoresIdProductsIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	productId string
}

func (r ApiDeleteEcommerceStoresIdProductsIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdProductsIdExecute(r)
}

/*
DeleteEcommerceStoresIdProductsId Delete product

Delete a product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @return ApiDeleteEcommerceStoresIdProductsIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdProductsId(ctx context.Context, storeId string, productId string) ApiDeleteEcommerceStoresIdProductsIdRequest {
	return ApiDeleteEcommerceStoresIdProductsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdProductsIdExecute(r ApiDeleteEcommerceStoresIdProductsIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdProductsId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteEcommerceStoresIdProductsIdImagesIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	productId string
	imageId string
}

func (r ApiDeleteEcommerceStoresIdProductsIdImagesIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdProductsIdImagesIdExecute(r)
}

/*
DeleteEcommerceStoresIdProductsIdImagesId Delete product image

Delete a product image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @param imageId The id for the product image.
 @return ApiDeleteEcommerceStoresIdProductsIdImagesIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdProductsIdImagesId(ctx context.Context, storeId string, productId string, imageId string) ApiDeleteEcommerceStoresIdProductsIdImagesIdRequest {
	return ApiDeleteEcommerceStoresIdProductsIdImagesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
		imageId: imageId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdProductsIdImagesIdExecute(r ApiDeleteEcommerceStoresIdProductsIdImagesIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdProductsIdImagesId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/images/{image_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"image_id"+"}", url.PathEscape(parameterValueToString(r.imageId, "imageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteEcommerceStoresIdProductsIdVariantsIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	productId string
	variantId string
}

func (r ApiDeleteEcommerceStoresIdProductsIdVariantsIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdProductsIdVariantsIdExecute(r)
}

/*
DeleteEcommerceStoresIdProductsIdVariantsId Delete product variant

Delete a product variant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @param variantId The id for the product variant.
 @return ApiDeleteEcommerceStoresIdProductsIdVariantsIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdProductsIdVariantsId(ctx context.Context, storeId string, productId string, variantId string) ApiDeleteEcommerceStoresIdProductsIdVariantsIdRequest {
	return ApiDeleteEcommerceStoresIdProductsIdVariantsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
		variantId: variantId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdProductsIdVariantsIdExecute(r ApiDeleteEcommerceStoresIdProductsIdVariantsIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdProductsIdVariantsId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/variants/{variant_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variant_id"+"}", url.PathEscape(parameterValueToString(r.variantId, "variantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteEcommerceStoresIdPromocodesIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	promoRuleId string
	promoCodeId string
}

func (r ApiDeleteEcommerceStoresIdPromocodesIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdPromocodesIdExecute(r)
}

/*
DeleteEcommerceStoresIdPromocodesId Delete promo code

Delete a promo code from a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param promoRuleId The id for the promo rule of a store.
 @param promoCodeId The id for the promo code of a store.
 @return ApiDeleteEcommerceStoresIdPromocodesIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdPromocodesId(ctx context.Context, storeId string, promoRuleId string, promoCodeId string) ApiDeleteEcommerceStoresIdPromocodesIdRequest {
	return ApiDeleteEcommerceStoresIdPromocodesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		promoRuleId: promoRuleId,
		promoCodeId: promoCodeId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdPromocodesIdExecute(r ApiDeleteEcommerceStoresIdPromocodesIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdPromocodesId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules/{promo_rule_id}/promo-codes/{promo_code_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_rule_id"+"}", url.PathEscape(parameterValueToString(r.promoRuleId, "promoRuleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_code_id"+"}", url.PathEscape(parameterValueToString(r.promoCodeId, "promoCodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteEcommerceStoresIdPromorulesIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	promoRuleId string
}

func (r ApiDeleteEcommerceStoresIdPromorulesIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdPromorulesIdExecute(r)
}

/*
DeleteEcommerceStoresIdPromorulesId Delete promo rule

Delete a promo rule from a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param promoRuleId The id for the promo rule of a store.
 @return ApiDeleteEcommerceStoresIdPromorulesIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdPromorulesId(ctx context.Context, storeId string, promoRuleId string) ApiDeleteEcommerceStoresIdPromorulesIdRequest {
	return ApiDeleteEcommerceStoresIdPromorulesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		promoRuleId: promoRuleId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdPromorulesIdExecute(r ApiDeleteEcommerceStoresIdPromorulesIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdPromorulesId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules/{promo_rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_rule_id"+"}", url.PathEscape(parameterValueToString(r.promoRuleId, "promoRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEcommerceOrdersRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	campaignId *string
	outreachId *string
	customerId *string
	hasOutreach *bool
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceOrdersRequest) Fields(fields []string) ApiGetEcommerceOrdersRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceOrdersRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceOrdersRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetEcommerceOrdersRequest) Count(count int32) ApiGetEcommerceOrdersRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetEcommerceOrdersRequest) Offset(offset int32) ApiGetEcommerceOrdersRequest {
	r.offset = &offset
	return r
}

// Restrict results to orders with a specific &#x60;campaign_id&#x60; value.
func (r ApiGetEcommerceOrdersRequest) CampaignId(campaignId string) ApiGetEcommerceOrdersRequest {
	r.campaignId = &campaignId
	return r
}

// Restrict results to orders with a specific &#x60;outreach_id&#x60; value.
func (r ApiGetEcommerceOrdersRequest) OutreachId(outreachId string) ApiGetEcommerceOrdersRequest {
	r.outreachId = &outreachId
	return r
}

// Restrict results to orders made by a specific customer.
func (r ApiGetEcommerceOrdersRequest) CustomerId(customerId string) ApiGetEcommerceOrdersRequest {
	r.customerId = &customerId
	return r
}

// Restrict results to orders that have an outreach attached. For example, an email campaign or Facebook ad.
func (r ApiGetEcommerceOrdersRequest) HasOutreach(hasOutreach bool) ApiGetEcommerceOrdersRequest {
	r.hasOutreach = &hasOutreach
	return r
}

func (r ApiGetEcommerceOrdersRequest) Execute() (*Orders, *http.Response, error) {
	return r.ApiService.GetEcommerceOrdersExecute(r)
}

/*
GetEcommerceOrders List account orders

Get information about an account's orders.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEcommerceOrdersRequest
*/
func (a *EcommerceAPIService) GetEcommerceOrders(ctx context.Context) ApiGetEcommerceOrdersRequest {
	return ApiGetEcommerceOrdersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Orders
func (a *EcommerceAPIService) GetEcommerceOrdersExecute(r ApiGetEcommerceOrdersRequest) (*Orders, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Orders
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceOrders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.campaignId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "campaign_id", r.campaignId, "")
	}
	if r.outreachId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outreach_id", r.outreachId, "")
	}
	if r.customerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customer_id", r.customerId, "")
	}
	if r.hasOutreach != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_outreach", r.hasOutreach, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresRequest) Fields(fields []string) ApiGetEcommerceStoresRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetEcommerceStoresRequest) Count(count int32) ApiGetEcommerceStoresRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetEcommerceStoresRequest) Offset(offset int32) ApiGetEcommerceStoresRequest {
	r.offset = &offset
	return r
}

func (r ApiGetEcommerceStoresRequest) Execute() (*ECommerceStores, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresExecute(r)
}

/*
GetEcommerceStores List stores

Get information about all stores in the account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEcommerceStoresRequest
*/
func (a *EcommerceAPIService) GetEcommerceStores(ctx context.Context) ApiGetEcommerceStoresRequest {
	return ApiGetEcommerceStoresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ECommerceStores
func (a *EcommerceAPIService) GetEcommerceStoresExecute(r ApiGetEcommerceStoresRequest) (*ECommerceStores, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceStores
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStores")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdRequest) Fields(fields []string) ApiGetEcommerceStoresIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetEcommerceStoresIdRequest) Execute() (*ECommerceStore, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdExecute(r)
}

/*
GetEcommerceStoresId Get store info

Get information about a specific store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return ApiGetEcommerceStoresIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresId(ctx context.Context, storeId string) ApiGetEcommerceStoresIdRequest {
	return ApiGetEcommerceStoresIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return ECommerceStore
func (a *EcommerceAPIService) GetEcommerceStoresIdExecute(r ApiGetEcommerceStoresIdRequest) (*ECommerceStore, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceStore
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdCartsRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdCartsRequest) Fields(fields []string) ApiGetEcommerceStoresIdCartsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdCartsRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdCartsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetEcommerceStoresIdCartsRequest) Count(count int32) ApiGetEcommerceStoresIdCartsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetEcommerceStoresIdCartsRequest) Offset(offset int32) ApiGetEcommerceStoresIdCartsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetEcommerceStoresIdCartsRequest) Execute() (*Carts, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdCartsExecute(r)
}

/*
GetEcommerceStoresIdCarts List carts

Get information about a store's carts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return ApiGetEcommerceStoresIdCartsRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdCarts(ctx context.Context, storeId string) ApiGetEcommerceStoresIdCartsRequest {
	return ApiGetEcommerceStoresIdCartsRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return Carts
func (a *EcommerceAPIService) GetEcommerceStoresIdCartsExecute(r ApiGetEcommerceStoresIdCartsRequest) (*Carts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Carts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdCarts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdCartsIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	cartId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdCartsIdRequest) Fields(fields []string) ApiGetEcommerceStoresIdCartsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdCartsIdRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdCartsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetEcommerceStoresIdCartsIdRequest) Execute() (*ECommerceCart, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdCartsIdExecute(r)
}

/*
GetEcommerceStoresIdCartsId Get cart info

Get information about a specific cart.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param cartId The id for the cart.
 @return ApiGetEcommerceStoresIdCartsIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdCartsId(ctx context.Context, storeId string, cartId string) ApiGetEcommerceStoresIdCartsIdRequest {
	return ApiGetEcommerceStoresIdCartsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		cartId: cartId,
	}
}

// Execute executes the request
//  @return ECommerceCart
func (a *EcommerceAPIService) GetEcommerceStoresIdCartsIdExecute(r ApiGetEcommerceStoresIdCartsIdRequest) (*ECommerceCart, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCart
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdCartsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts/{cart_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cart_id"+"}", url.PathEscape(parameterValueToString(r.cartId, "cartId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdCartsIdLinesRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	cartId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdCartsIdLinesRequest) Fields(fields []string) ApiGetEcommerceStoresIdCartsIdLinesRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdCartsIdLinesRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdCartsIdLinesRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetEcommerceStoresIdCartsIdLinesRequest) Count(count int32) ApiGetEcommerceStoresIdCartsIdLinesRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetEcommerceStoresIdCartsIdLinesRequest) Offset(offset int32) ApiGetEcommerceStoresIdCartsIdLinesRequest {
	r.offset = &offset
	return r
}

func (r ApiGetEcommerceStoresIdCartsIdLinesRequest) Execute() (*CartLines, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdCartsIdLinesExecute(r)
}

/*
GetEcommerceStoresIdCartsIdLines List cart line items

Get information about a cart's line items.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param cartId The id for the cart.
 @return ApiGetEcommerceStoresIdCartsIdLinesRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdCartsIdLines(ctx context.Context, storeId string, cartId string) ApiGetEcommerceStoresIdCartsIdLinesRequest {
	return ApiGetEcommerceStoresIdCartsIdLinesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		cartId: cartId,
	}
}

// Execute executes the request
//  @return CartLines
func (a *EcommerceAPIService) GetEcommerceStoresIdCartsIdLinesExecute(r ApiGetEcommerceStoresIdCartsIdLinesRequest) (*CartLines, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CartLines
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdCartsIdLines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts/{cart_id}/lines"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cart_id"+"}", url.PathEscape(parameterValueToString(r.cartId, "cartId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdCartsIdLinesIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	cartId string
	lineId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdCartsIdLinesIdRequest) Fields(fields []string) ApiGetEcommerceStoresIdCartsIdLinesIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdCartsIdLinesIdRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdCartsIdLinesIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetEcommerceStoresIdCartsIdLinesIdRequest) Execute() (*ECommerceCartLineItem, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdCartsIdLinesIdExecute(r)
}

/*
GetEcommerceStoresIdCartsIdLinesId Get cart line item

Get information about a specific cart line item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param cartId The id for the cart.
 @param lineId The id for the line item of a cart.
 @return ApiGetEcommerceStoresIdCartsIdLinesIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdCartsIdLinesId(ctx context.Context, storeId string, cartId string, lineId string) ApiGetEcommerceStoresIdCartsIdLinesIdRequest {
	return ApiGetEcommerceStoresIdCartsIdLinesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		cartId: cartId,
		lineId: lineId,
	}
}

// Execute executes the request
//  @return ECommerceCartLineItem
func (a *EcommerceAPIService) GetEcommerceStoresIdCartsIdLinesIdExecute(r ApiGetEcommerceStoresIdCartsIdLinesIdRequest) (*ECommerceCartLineItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCartLineItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdCartsIdLinesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts/{cart_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cart_id"+"}", url.PathEscape(parameterValueToString(r.cartId, "cartId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdCustomersRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	emailAddress *string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdCustomersRequest) Fields(fields []string) ApiGetEcommerceStoresIdCustomersRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdCustomersRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdCustomersRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetEcommerceStoresIdCustomersRequest) Count(count int32) ApiGetEcommerceStoresIdCustomersRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetEcommerceStoresIdCustomersRequest) Offset(offset int32) ApiGetEcommerceStoresIdCustomersRequest {
	r.offset = &offset
	return r
}

// Restrict the response to customers with the email address.
func (r ApiGetEcommerceStoresIdCustomersRequest) EmailAddress(emailAddress string) ApiGetEcommerceStoresIdCustomersRequest {
	r.emailAddress = &emailAddress
	return r
}

func (r ApiGetEcommerceStoresIdCustomersRequest) Execute() (*Customers, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdCustomersExecute(r)
}

/*
GetEcommerceStoresIdCustomers List customers

Get information about a store's customers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return ApiGetEcommerceStoresIdCustomersRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdCustomers(ctx context.Context, storeId string) ApiGetEcommerceStoresIdCustomersRequest {
	return ApiGetEcommerceStoresIdCustomersRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return Customers
func (a *EcommerceAPIService) GetEcommerceStoresIdCustomersExecute(r ApiGetEcommerceStoresIdCustomersRequest) (*Customers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Customers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdCustomers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/customers"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.emailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email_address", r.emailAddress, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdCustomersIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	customerId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdCustomersIdRequest) Fields(fields []string) ApiGetEcommerceStoresIdCustomersIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdCustomersIdRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdCustomersIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetEcommerceStoresIdCustomersIdRequest) Execute() (*ECommerceCustomer, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdCustomersIdExecute(r)
}

/*
GetEcommerceStoresIdCustomersId Get customer info

Get information about a specific customer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param customerId The id for the customer of a store.
 @return ApiGetEcommerceStoresIdCustomersIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdCustomersId(ctx context.Context, storeId string, customerId string) ApiGetEcommerceStoresIdCustomersIdRequest {
	return ApiGetEcommerceStoresIdCustomersIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		customerId: customerId,
	}
}

// Execute executes the request
//  @return ECommerceCustomer
func (a *EcommerceAPIService) GetEcommerceStoresIdCustomersIdExecute(r ApiGetEcommerceStoresIdCustomersIdRequest) (*ECommerceCustomer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCustomer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdCustomersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/customers/{customer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customer_id"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdOrdersRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	customerId *string
	hasOutreach *bool
	campaignId *string
	outreachId *string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdOrdersRequest) Fields(fields []string) ApiGetEcommerceStoresIdOrdersRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdOrdersRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdOrdersRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetEcommerceStoresIdOrdersRequest) Count(count int32) ApiGetEcommerceStoresIdOrdersRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetEcommerceStoresIdOrdersRequest) Offset(offset int32) ApiGetEcommerceStoresIdOrdersRequest {
	r.offset = &offset
	return r
}

// Restrict results to orders made by a specific customer.
func (r ApiGetEcommerceStoresIdOrdersRequest) CustomerId(customerId string) ApiGetEcommerceStoresIdOrdersRequest {
	r.customerId = &customerId
	return r
}

// Restrict results to orders that have an outreach attached. For example, an email campaign or Facebook ad.
func (r ApiGetEcommerceStoresIdOrdersRequest) HasOutreach(hasOutreach bool) ApiGetEcommerceStoresIdOrdersRequest {
	r.hasOutreach = &hasOutreach
	return r
}

// Restrict results to orders with a specific &#x60;campaign_id&#x60; value.
func (r ApiGetEcommerceStoresIdOrdersRequest) CampaignId(campaignId string) ApiGetEcommerceStoresIdOrdersRequest {
	r.campaignId = &campaignId
	return r
}

// Restrict results to orders with a specific &#x60;outreach_id&#x60; value.
func (r ApiGetEcommerceStoresIdOrdersRequest) OutreachId(outreachId string) ApiGetEcommerceStoresIdOrdersRequest {
	r.outreachId = &outreachId
	return r
}

func (r ApiGetEcommerceStoresIdOrdersRequest) Execute() (*Orders1, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdOrdersExecute(r)
}

/*
GetEcommerceStoresIdOrders List orders

Get information about a store's orders.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return ApiGetEcommerceStoresIdOrdersRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdOrders(ctx context.Context, storeId string) ApiGetEcommerceStoresIdOrdersRequest {
	return ApiGetEcommerceStoresIdOrdersRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return Orders1
func (a *EcommerceAPIService) GetEcommerceStoresIdOrdersExecute(r ApiGetEcommerceStoresIdOrdersRequest) (*Orders1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Orders1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdOrders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.customerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customer_id", r.customerId, "")
	}
	if r.hasOutreach != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_outreach", r.hasOutreach, "")
	}
	if r.campaignId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "campaign_id", r.campaignId, "")
	}
	if r.outreachId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outreach_id", r.outreachId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdOrdersIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	orderId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdOrdersIdRequest) Fields(fields []string) ApiGetEcommerceStoresIdOrdersIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdOrdersIdRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdOrdersIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetEcommerceStoresIdOrdersIdRequest) Execute() (*ECommerceOrder, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdOrdersIdExecute(r)
}

/*
GetEcommerceStoresIdOrdersId Get order info

Get information about a specific order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param orderId The id for the order in a store.
 @return ApiGetEcommerceStoresIdOrdersIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdOrdersId(ctx context.Context, storeId string, orderId string) ApiGetEcommerceStoresIdOrdersIdRequest {
	return ApiGetEcommerceStoresIdOrdersIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		orderId: orderId,
	}
}

// Execute executes the request
//  @return ECommerceOrder
func (a *EcommerceAPIService) GetEcommerceStoresIdOrdersIdExecute(r ApiGetEcommerceStoresIdOrdersIdRequest) (*ECommerceOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdOrdersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders/{order_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdOrdersIdLinesRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	orderId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdOrdersIdLinesRequest) Fields(fields []string) ApiGetEcommerceStoresIdOrdersIdLinesRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdOrdersIdLinesRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdOrdersIdLinesRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetEcommerceStoresIdOrdersIdLinesRequest) Count(count int32) ApiGetEcommerceStoresIdOrdersIdLinesRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetEcommerceStoresIdOrdersIdLinesRequest) Offset(offset int32) ApiGetEcommerceStoresIdOrdersIdLinesRequest {
	r.offset = &offset
	return r
}

func (r ApiGetEcommerceStoresIdOrdersIdLinesRequest) Execute() (*OrderLines, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdOrdersIdLinesExecute(r)
}

/*
GetEcommerceStoresIdOrdersIdLines List order line items

Get information about an order's line items.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param orderId The id for the order in a store.
 @return ApiGetEcommerceStoresIdOrdersIdLinesRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdOrdersIdLines(ctx context.Context, storeId string, orderId string) ApiGetEcommerceStoresIdOrdersIdLinesRequest {
	return ApiGetEcommerceStoresIdOrdersIdLinesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		orderId: orderId,
	}
}

// Execute executes the request
//  @return OrderLines
func (a *EcommerceAPIService) GetEcommerceStoresIdOrdersIdLinesExecute(r ApiGetEcommerceStoresIdOrdersIdLinesRequest) (*OrderLines, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderLines
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdOrdersIdLines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders/{order_id}/lines"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdOrdersIdLinesIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	orderId string
	lineId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdOrdersIdLinesIdRequest) Fields(fields []string) ApiGetEcommerceStoresIdOrdersIdLinesIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdOrdersIdLinesIdRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdOrdersIdLinesIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetEcommerceStoresIdOrdersIdLinesIdRequest) Execute() (*ECommerceOrderLineItem, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdOrdersIdLinesIdExecute(r)
}

/*
GetEcommerceStoresIdOrdersIdLinesId Get order line item

Get information about a specific order line item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param orderId The id for the order in a store.
 @param lineId The id for the line item of an order.
 @return ApiGetEcommerceStoresIdOrdersIdLinesIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdOrdersIdLinesId(ctx context.Context, storeId string, orderId string, lineId string) ApiGetEcommerceStoresIdOrdersIdLinesIdRequest {
	return ApiGetEcommerceStoresIdOrdersIdLinesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		orderId: orderId,
		lineId: lineId,
	}
}

// Execute executes the request
//  @return ECommerceOrderLineItem
func (a *EcommerceAPIService) GetEcommerceStoresIdOrdersIdLinesIdExecute(r ApiGetEcommerceStoresIdOrdersIdLinesIdRequest) (*ECommerceOrderLineItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceOrderLineItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdOrdersIdLinesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders/{order_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdProductsRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdProductsRequest) Fields(fields []string) ApiGetEcommerceStoresIdProductsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdProductsRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdProductsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetEcommerceStoresIdProductsRequest) Count(count int32) ApiGetEcommerceStoresIdProductsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetEcommerceStoresIdProductsRequest) Offset(offset int32) ApiGetEcommerceStoresIdProductsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetEcommerceStoresIdProductsRequest) Execute() (*Products, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdProductsExecute(r)
}

/*
GetEcommerceStoresIdProducts List product

Get information about a store's products.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return ApiGetEcommerceStoresIdProductsRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdProducts(ctx context.Context, storeId string) ApiGetEcommerceStoresIdProductsRequest {
	return ApiGetEcommerceStoresIdProductsRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return Products
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsExecute(r ApiGetEcommerceStoresIdProductsRequest) (*Products, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Products
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdProducts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdProductsIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	productId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdProductsIdRequest) Fields(fields []string) ApiGetEcommerceStoresIdProductsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdProductsIdRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdProductsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetEcommerceStoresIdProductsIdRequest) Execute() (*ECommerceProduct, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdProductsIdExecute(r)
}

/*
GetEcommerceStoresIdProductsId Get product info

Get information about a specific product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @return ApiGetEcommerceStoresIdProductsIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsId(ctx context.Context, storeId string, productId string) ApiGetEcommerceStoresIdProductsIdRequest {
	return ApiGetEcommerceStoresIdProductsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
	}
}

// Execute executes the request
//  @return ECommerceProduct
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdExecute(r ApiGetEcommerceStoresIdProductsIdRequest) (*ECommerceProduct, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProduct
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdProductsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdProductsIdImagesRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	productId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdProductsIdImagesRequest) Fields(fields []string) ApiGetEcommerceStoresIdProductsIdImagesRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdProductsIdImagesRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdProductsIdImagesRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetEcommerceStoresIdProductsIdImagesRequest) Count(count int32) ApiGetEcommerceStoresIdProductsIdImagesRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetEcommerceStoresIdProductsIdImagesRequest) Offset(offset int32) ApiGetEcommerceStoresIdProductsIdImagesRequest {
	r.offset = &offset
	return r
}

func (r ApiGetEcommerceStoresIdProductsIdImagesRequest) Execute() (*EcommerceProductImages, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdProductsIdImagesExecute(r)
}

/*
GetEcommerceStoresIdProductsIdImages List product images

Get information about a product's images.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @return ApiGetEcommerceStoresIdProductsIdImagesRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdImages(ctx context.Context, storeId string, productId string) ApiGetEcommerceStoresIdProductsIdImagesRequest {
	return ApiGetEcommerceStoresIdProductsIdImagesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
	}
}

// Execute executes the request
//  @return EcommerceProductImages
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdImagesExecute(r ApiGetEcommerceStoresIdProductsIdImagesRequest) (*EcommerceProductImages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EcommerceProductImages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdProductsIdImages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/images"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdProductsIdImagesIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	productId string
	imageId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdProductsIdImagesIdRequest) Fields(fields []string) ApiGetEcommerceStoresIdProductsIdImagesIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdProductsIdImagesIdRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdProductsIdImagesIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetEcommerceStoresIdProductsIdImagesIdRequest) Execute() (*ECommerceProductImage, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdProductsIdImagesIdExecute(r)
}

/*
GetEcommerceStoresIdProductsIdImagesId Get product image info

Get information about a specific product image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @param imageId The id for the product image.
 @return ApiGetEcommerceStoresIdProductsIdImagesIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdImagesId(ctx context.Context, storeId string, productId string, imageId string) ApiGetEcommerceStoresIdProductsIdImagesIdRequest {
	return ApiGetEcommerceStoresIdProductsIdImagesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
		imageId: imageId,
	}
}

// Execute executes the request
//  @return ECommerceProductImage
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdImagesIdExecute(r ApiGetEcommerceStoresIdProductsIdImagesIdRequest) (*ECommerceProductImage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProductImage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdProductsIdImagesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/images/{image_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"image_id"+"}", url.PathEscape(parameterValueToString(r.imageId, "imageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdProductsIdVariantsRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	productId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdProductsIdVariantsRequest) Fields(fields []string) ApiGetEcommerceStoresIdProductsIdVariantsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdProductsIdVariantsRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdProductsIdVariantsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetEcommerceStoresIdProductsIdVariantsRequest) Count(count int32) ApiGetEcommerceStoresIdProductsIdVariantsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetEcommerceStoresIdProductsIdVariantsRequest) Offset(offset int32) ApiGetEcommerceStoresIdProductsIdVariantsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetEcommerceStoresIdProductsIdVariantsRequest) Execute() (*EcommerceProductVariants, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdProductsIdVariantsExecute(r)
}

/*
GetEcommerceStoresIdProductsIdVariants List product variants

Get information about a product's variants.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @return ApiGetEcommerceStoresIdProductsIdVariantsRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdVariants(ctx context.Context, storeId string, productId string) ApiGetEcommerceStoresIdProductsIdVariantsRequest {
	return ApiGetEcommerceStoresIdProductsIdVariantsRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
	}
}

// Execute executes the request
//  @return EcommerceProductVariants
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdVariantsExecute(r ApiGetEcommerceStoresIdProductsIdVariantsRequest) (*EcommerceProductVariants, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EcommerceProductVariants
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdProductsIdVariants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/variants"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdProductsIdVariantsIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	productId string
	variantId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdProductsIdVariantsIdRequest) Fields(fields []string) ApiGetEcommerceStoresIdProductsIdVariantsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdProductsIdVariantsIdRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdProductsIdVariantsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetEcommerceStoresIdProductsIdVariantsIdRequest) Execute() (*ECommerceProductVariant, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdProductsIdVariantsIdExecute(r)
}

/*
GetEcommerceStoresIdProductsIdVariantsId Get product variant info

Get information about a specific product variant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @param variantId The id for the product variant.
 @return ApiGetEcommerceStoresIdProductsIdVariantsIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdVariantsId(ctx context.Context, storeId string, productId string, variantId string) ApiGetEcommerceStoresIdProductsIdVariantsIdRequest {
	return ApiGetEcommerceStoresIdProductsIdVariantsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
		variantId: variantId,
	}
}

// Execute executes the request
//  @return ECommerceProductVariant
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdVariantsIdExecute(r ApiGetEcommerceStoresIdProductsIdVariantsIdRequest) (*ECommerceProductVariant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProductVariant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdProductsIdVariantsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/variants/{variant_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variant_id"+"}", url.PathEscape(parameterValueToString(r.variantId, "variantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdPromocodesRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	promoRuleId string
	storeId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdPromocodesRequest) Fields(fields []string) ApiGetEcommerceStoresIdPromocodesRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdPromocodesRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdPromocodesRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetEcommerceStoresIdPromocodesRequest) Count(count int32) ApiGetEcommerceStoresIdPromocodesRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetEcommerceStoresIdPromocodesRequest) Offset(offset int32) ApiGetEcommerceStoresIdPromocodesRequest {
	r.offset = &offset
	return r
}

func (r ApiGetEcommerceStoresIdPromocodesRequest) Execute() (*PromoCodes, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdPromocodesExecute(r)
}

/*
GetEcommerceStoresIdPromocodes List promo codes

Get information about a store's promo codes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param promoRuleId The id for the promo rule of a store.
 @param storeId The store id.
 @return ApiGetEcommerceStoresIdPromocodesRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdPromocodes(ctx context.Context, promoRuleId string, storeId string) ApiGetEcommerceStoresIdPromocodesRequest {
	return ApiGetEcommerceStoresIdPromocodesRequest{
		ApiService: a,
		ctx: ctx,
		promoRuleId: promoRuleId,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return PromoCodes
func (a *EcommerceAPIService) GetEcommerceStoresIdPromocodesExecute(r ApiGetEcommerceStoresIdPromocodesRequest) (*PromoCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PromoCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdPromocodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules/{promo_rule_id}/promo-codes"
	localVarPath = strings.Replace(localVarPath, "{"+"promo_rule_id"+"}", url.PathEscape(parameterValueToString(r.promoRuleId, "promoRuleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdPromocodesIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	promoRuleId string
	promoCodeId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdPromocodesIdRequest) Fields(fields []string) ApiGetEcommerceStoresIdPromocodesIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdPromocodesIdRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdPromocodesIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetEcommerceStoresIdPromocodesIdRequest) Execute() (*ECommercePromoCode, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdPromocodesIdExecute(r)
}

/*
GetEcommerceStoresIdPromocodesId Get promo code

Get information about a specific promo code.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param promoRuleId The id for the promo rule of a store.
 @param promoCodeId The id for the promo code of a store.
 @return ApiGetEcommerceStoresIdPromocodesIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdPromocodesId(ctx context.Context, storeId string, promoRuleId string, promoCodeId string) ApiGetEcommerceStoresIdPromocodesIdRequest {
	return ApiGetEcommerceStoresIdPromocodesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		promoRuleId: promoRuleId,
		promoCodeId: promoCodeId,
	}
}

// Execute executes the request
//  @return ECommercePromoCode
func (a *EcommerceAPIService) GetEcommerceStoresIdPromocodesIdExecute(r ApiGetEcommerceStoresIdPromocodesIdRequest) (*ECommercePromoCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommercePromoCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdPromocodesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules/{promo_rule_id}/promo-codes/{promo_code_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_rule_id"+"}", url.PathEscape(parameterValueToString(r.promoRuleId, "promoRuleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_code_id"+"}", url.PathEscape(parameterValueToString(r.promoCodeId, "promoCodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdPromorulesRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdPromorulesRequest) Fields(fields []string) ApiGetEcommerceStoresIdPromorulesRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdPromorulesRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdPromorulesRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ApiGetEcommerceStoresIdPromorulesRequest) Count(count int32) ApiGetEcommerceStoresIdPromorulesRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ApiGetEcommerceStoresIdPromorulesRequest) Offset(offset int32) ApiGetEcommerceStoresIdPromorulesRequest {
	r.offset = &offset
	return r
}

func (r ApiGetEcommerceStoresIdPromorulesRequest) Execute() (*PromoRules, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdPromorulesExecute(r)
}

/*
GetEcommerceStoresIdPromorules List promo rules

Get information about a store's promo rules.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return ApiGetEcommerceStoresIdPromorulesRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdPromorules(ctx context.Context, storeId string) ApiGetEcommerceStoresIdPromorulesRequest {
	return ApiGetEcommerceStoresIdPromorulesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return PromoRules
func (a *EcommerceAPIService) GetEcommerceStoresIdPromorulesExecute(r ApiGetEcommerceStoresIdPromorulesRequest) (*PromoRules, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PromoRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdPromorules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEcommerceStoresIdPromorulesIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	promoRuleId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdPromorulesIdRequest) Fields(fields []string) ApiGetEcommerceStoresIdPromorulesIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ApiGetEcommerceStoresIdPromorulesIdRequest) ExcludeFields(excludeFields []string) ApiGetEcommerceStoresIdPromorulesIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ApiGetEcommerceStoresIdPromorulesIdRequest) Execute() (*ECommercePromoRule, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdPromorulesIdExecute(r)
}

/*
GetEcommerceStoresIdPromorulesId Get promo rule

Get information about a specific promo rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param promoRuleId The id for the promo rule of a store.
 @return ApiGetEcommerceStoresIdPromorulesIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdPromorulesId(ctx context.Context, storeId string, promoRuleId string) ApiGetEcommerceStoresIdPromorulesIdRequest {
	return ApiGetEcommerceStoresIdPromorulesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		promoRuleId: promoRuleId,
	}
}

// Execute executes the request
//  @return ECommercePromoRule
func (a *EcommerceAPIService) GetEcommerceStoresIdPromorulesIdExecute(r ApiGetEcommerceStoresIdPromorulesIdRequest) (*ECommercePromoRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommercePromoRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdPromorulesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules/{promo_rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_rule_id"+"}", url.PathEscape(parameterValueToString(r.promoRuleId, "promoRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchEcommerceStoresIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	body *ECommerceStore2
}

func (r ApiPatchEcommerceStoresIdRequest) Body(body ECommerceStore2) ApiPatchEcommerceStoresIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchEcommerceStoresIdRequest) Execute() (*ECommerceStore, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdExecute(r)
}

/*
PatchEcommerceStoresId Update store

Update a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return ApiPatchEcommerceStoresIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresId(ctx context.Context, storeId string) ApiPatchEcommerceStoresIdRequest {
	return ApiPatchEcommerceStoresIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return ECommerceStore
func (a *EcommerceAPIService) PatchEcommerceStoresIdExecute(r ApiPatchEcommerceStoresIdRequest) (*ECommerceStore, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceStore
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchEcommerceStoresIdCartsIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	cartId string
	body *ECommerceCart2
}

func (r ApiPatchEcommerceStoresIdCartsIdRequest) Body(body ECommerceCart2) ApiPatchEcommerceStoresIdCartsIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchEcommerceStoresIdCartsIdRequest) Execute() (*ECommerceCart, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdCartsIdExecute(r)
}

/*
PatchEcommerceStoresIdCartsId Update cart

Update a specific cart.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param cartId The id for the cart.
 @return ApiPatchEcommerceStoresIdCartsIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdCartsId(ctx context.Context, storeId string, cartId string) ApiPatchEcommerceStoresIdCartsIdRequest {
	return ApiPatchEcommerceStoresIdCartsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		cartId: cartId,
	}
}

// Execute executes the request
//  @return ECommerceCart
func (a *EcommerceAPIService) PatchEcommerceStoresIdCartsIdExecute(r ApiPatchEcommerceStoresIdCartsIdRequest) (*ECommerceCart, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCart
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdCartsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts/{cart_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cart_id"+"}", url.PathEscape(parameterValueToString(r.cartId, "cartId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchEcommerceStoresIdCartsIdLinesIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	cartId string
	lineId string
	body *ECommerceCartLineItem2
}

func (r ApiPatchEcommerceStoresIdCartsIdLinesIdRequest) Body(body ECommerceCartLineItem2) ApiPatchEcommerceStoresIdCartsIdLinesIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchEcommerceStoresIdCartsIdLinesIdRequest) Execute() (*ECommerceCartLineItem, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdCartsIdLinesIdExecute(r)
}

/*
PatchEcommerceStoresIdCartsIdLinesId Update cart line item

Update a specific cart line item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param cartId The id for the cart.
 @param lineId The id for the line item of a cart.
 @return ApiPatchEcommerceStoresIdCartsIdLinesIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdCartsIdLinesId(ctx context.Context, storeId string, cartId string, lineId string) ApiPatchEcommerceStoresIdCartsIdLinesIdRequest {
	return ApiPatchEcommerceStoresIdCartsIdLinesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		cartId: cartId,
		lineId: lineId,
	}
}

// Execute executes the request
//  @return ECommerceCartLineItem
func (a *EcommerceAPIService) PatchEcommerceStoresIdCartsIdLinesIdExecute(r ApiPatchEcommerceStoresIdCartsIdLinesIdRequest) (*ECommerceCartLineItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCartLineItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdCartsIdLinesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts/{cart_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cart_id"+"}", url.PathEscape(parameterValueToString(r.cartId, "cartId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchEcommerceStoresIdCustomersIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	customerId string
	body *ECommerceCustomer2
}

func (r ApiPatchEcommerceStoresIdCustomersIdRequest) Body(body ECommerceCustomer2) ApiPatchEcommerceStoresIdCustomersIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchEcommerceStoresIdCustomersIdRequest) Execute() (*ECommerceCustomer, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdCustomersIdExecute(r)
}

/*
PatchEcommerceStoresIdCustomersId Update customer

Update a customer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param customerId The id for the customer of a store.
 @return ApiPatchEcommerceStoresIdCustomersIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdCustomersId(ctx context.Context, storeId string, customerId string) ApiPatchEcommerceStoresIdCustomersIdRequest {
	return ApiPatchEcommerceStoresIdCustomersIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		customerId: customerId,
	}
}

// Execute executes the request
//  @return ECommerceCustomer
func (a *EcommerceAPIService) PatchEcommerceStoresIdCustomersIdExecute(r ApiPatchEcommerceStoresIdCustomersIdRequest) (*ECommerceCustomer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCustomer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdCustomersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/customers/{customer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customer_id"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchEcommerceStoresIdOrdersIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	orderId string
	body *ECommerceOrder2
}

func (r ApiPatchEcommerceStoresIdOrdersIdRequest) Body(body ECommerceOrder2) ApiPatchEcommerceStoresIdOrdersIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchEcommerceStoresIdOrdersIdRequest) Execute() (*ECommerceOrder, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdOrdersIdExecute(r)
}

/*
PatchEcommerceStoresIdOrdersId Update order

Update a specific order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param orderId The id for the order in a store.
 @return ApiPatchEcommerceStoresIdOrdersIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdOrdersId(ctx context.Context, storeId string, orderId string) ApiPatchEcommerceStoresIdOrdersIdRequest {
	return ApiPatchEcommerceStoresIdOrdersIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		orderId: orderId,
	}
}

// Execute executes the request
//  @return ECommerceOrder
func (a *EcommerceAPIService) PatchEcommerceStoresIdOrdersIdExecute(r ApiPatchEcommerceStoresIdOrdersIdRequest) (*ECommerceOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdOrdersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders/{order_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchEcommerceStoresIdOrdersIdLinesIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	orderId string
	lineId string
	body *ECommerceOrderLineItem2
}

func (r ApiPatchEcommerceStoresIdOrdersIdLinesIdRequest) Body(body ECommerceOrderLineItem2) ApiPatchEcommerceStoresIdOrdersIdLinesIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchEcommerceStoresIdOrdersIdLinesIdRequest) Execute() (*ECommerceOrderLineItem, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdOrdersIdLinesIdExecute(r)
}

/*
PatchEcommerceStoresIdOrdersIdLinesId Update order line item

Update a specific order line item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param orderId The id for the order in a store.
 @param lineId The id for the line item of an order.
 @return ApiPatchEcommerceStoresIdOrdersIdLinesIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdOrdersIdLinesId(ctx context.Context, storeId string, orderId string, lineId string) ApiPatchEcommerceStoresIdOrdersIdLinesIdRequest {
	return ApiPatchEcommerceStoresIdOrdersIdLinesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		orderId: orderId,
		lineId: lineId,
	}
}

// Execute executes the request
//  @return ECommerceOrderLineItem
func (a *EcommerceAPIService) PatchEcommerceStoresIdOrdersIdLinesIdExecute(r ApiPatchEcommerceStoresIdOrdersIdLinesIdRequest) (*ECommerceOrderLineItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceOrderLineItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdOrdersIdLinesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders/{order_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchEcommerceStoresIdProductsIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	productId string
	body *ECommerceProduct2
}

func (r ApiPatchEcommerceStoresIdProductsIdRequest) Body(body ECommerceProduct2) ApiPatchEcommerceStoresIdProductsIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchEcommerceStoresIdProductsIdRequest) Execute() (*ECommerceProduct, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdProductsIdExecute(r)
}

/*
PatchEcommerceStoresIdProductsId Update product

Update a specific product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @return ApiPatchEcommerceStoresIdProductsIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdProductsId(ctx context.Context, storeId string, productId string) ApiPatchEcommerceStoresIdProductsIdRequest {
	return ApiPatchEcommerceStoresIdProductsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
	}
}

// Execute executes the request
//  @return ECommerceProduct
func (a *EcommerceAPIService) PatchEcommerceStoresIdProductsIdExecute(r ApiPatchEcommerceStoresIdProductsIdRequest) (*ECommerceProduct, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProduct
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdProductsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchEcommerceStoresIdProductsIdImagesIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	productId string
	imageId string
	body *ECommerceProductImage2
}

func (r ApiPatchEcommerceStoresIdProductsIdImagesIdRequest) Body(body ECommerceProductImage2) ApiPatchEcommerceStoresIdProductsIdImagesIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchEcommerceStoresIdProductsIdImagesIdRequest) Execute() (*ECommerceProductImage, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdProductsIdImagesIdExecute(r)
}

/*
PatchEcommerceStoresIdProductsIdImagesId Update product image

Update a product image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @param imageId The id for the product image.
 @return ApiPatchEcommerceStoresIdProductsIdImagesIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdProductsIdImagesId(ctx context.Context, storeId string, productId string, imageId string) ApiPatchEcommerceStoresIdProductsIdImagesIdRequest {
	return ApiPatchEcommerceStoresIdProductsIdImagesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
		imageId: imageId,
	}
}

// Execute executes the request
//  @return ECommerceProductImage
func (a *EcommerceAPIService) PatchEcommerceStoresIdProductsIdImagesIdExecute(r ApiPatchEcommerceStoresIdProductsIdImagesIdRequest) (*ECommerceProductImage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProductImage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdProductsIdImagesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/images/{image_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"image_id"+"}", url.PathEscape(parameterValueToString(r.imageId, "imageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchEcommerceStoresIdProductsIdVariantsIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	productId string
	variantId string
	body *ECommerceProductVariant2
}

func (r ApiPatchEcommerceStoresIdProductsIdVariantsIdRequest) Body(body ECommerceProductVariant2) ApiPatchEcommerceStoresIdProductsIdVariantsIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchEcommerceStoresIdProductsIdVariantsIdRequest) Execute() (*ECommerceProductVariant, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdProductsIdVariantsIdExecute(r)
}

/*
PatchEcommerceStoresIdProductsIdVariantsId Update product variant

Update a product variant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @param variantId The id for the product variant.
 @return ApiPatchEcommerceStoresIdProductsIdVariantsIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdProductsIdVariantsId(ctx context.Context, storeId string, productId string, variantId string) ApiPatchEcommerceStoresIdProductsIdVariantsIdRequest {
	return ApiPatchEcommerceStoresIdProductsIdVariantsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
		variantId: variantId,
	}
}

// Execute executes the request
//  @return ECommerceProductVariant
func (a *EcommerceAPIService) PatchEcommerceStoresIdProductsIdVariantsIdExecute(r ApiPatchEcommerceStoresIdProductsIdVariantsIdRequest) (*ECommerceProductVariant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProductVariant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdProductsIdVariantsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/variants/{variant_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variant_id"+"}", url.PathEscape(parameterValueToString(r.variantId, "variantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchEcommerceStoresIdPromocodesIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	promoRuleId string
	promoCodeId string
	body *ECommercePromoCode2
}

func (r ApiPatchEcommerceStoresIdPromocodesIdRequest) Body(body ECommercePromoCode2) ApiPatchEcommerceStoresIdPromocodesIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchEcommerceStoresIdPromocodesIdRequest) Execute() (*ECommercePromoCode, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdPromocodesIdExecute(r)
}

/*
PatchEcommerceStoresIdPromocodesId Update promo code

Update a promo code.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param promoRuleId The id for the promo rule of a store.
 @param promoCodeId The id for the promo code of a store.
 @return ApiPatchEcommerceStoresIdPromocodesIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdPromocodesId(ctx context.Context, storeId string, promoRuleId string, promoCodeId string) ApiPatchEcommerceStoresIdPromocodesIdRequest {
	return ApiPatchEcommerceStoresIdPromocodesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		promoRuleId: promoRuleId,
		promoCodeId: promoCodeId,
	}
}

// Execute executes the request
//  @return ECommercePromoCode
func (a *EcommerceAPIService) PatchEcommerceStoresIdPromocodesIdExecute(r ApiPatchEcommerceStoresIdPromocodesIdRequest) (*ECommercePromoCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommercePromoCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdPromocodesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules/{promo_rule_id}/promo-codes/{promo_code_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_rule_id"+"}", url.PathEscape(parameterValueToString(r.promoRuleId, "promoRuleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_code_id"+"}", url.PathEscape(parameterValueToString(r.promoCodeId, "promoCodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchEcommerceStoresIdPromorulesIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	promoRuleId string
	body *ECommercePromoRule2
}

func (r ApiPatchEcommerceStoresIdPromorulesIdRequest) Body(body ECommercePromoRule2) ApiPatchEcommerceStoresIdPromorulesIdRequest {
	r.body = &body
	return r
}

func (r ApiPatchEcommerceStoresIdPromorulesIdRequest) Execute() (*ECommercePromoRule, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdPromorulesIdExecute(r)
}

/*
PatchEcommerceStoresIdPromorulesId Update promo rule

Update a promo rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param promoRuleId The id for the promo rule of a store.
 @return ApiPatchEcommerceStoresIdPromorulesIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdPromorulesId(ctx context.Context, storeId string, promoRuleId string) ApiPatchEcommerceStoresIdPromorulesIdRequest {
	return ApiPatchEcommerceStoresIdPromorulesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		promoRuleId: promoRuleId,
	}
}

// Execute executes the request
//  @return ECommercePromoRule
func (a *EcommerceAPIService) PatchEcommerceStoresIdPromorulesIdExecute(r ApiPatchEcommerceStoresIdPromorulesIdRequest) (*ECommercePromoRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommercePromoRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdPromorulesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules/{promo_rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_rule_id"+"}", url.PathEscape(parameterValueToString(r.promoRuleId, "promoRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEcommerceStoresRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	body *ECommerceStore1
}

func (r ApiPostEcommerceStoresRequest) Body(body ECommerceStore1) ApiPostEcommerceStoresRequest {
	r.body = &body
	return r
}

func (r ApiPostEcommerceStoresRequest) Execute() (*ECommerceStore, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresExecute(r)
}

/*
PostEcommerceStores Add store

Add a new store to your Mailchimp account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostEcommerceStoresRequest
*/
func (a *EcommerceAPIService) PostEcommerceStores(ctx context.Context) ApiPostEcommerceStoresRequest {
	return ApiPostEcommerceStoresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ECommerceStore
func (a *EcommerceAPIService) PostEcommerceStoresExecute(r ApiPostEcommerceStoresRequest) (*ECommerceStore, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceStore
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStores")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEcommerceStoresIdCartsRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	body *ECommerceCart1
}

func (r ApiPostEcommerceStoresIdCartsRequest) Body(body ECommerceCart1) ApiPostEcommerceStoresIdCartsRequest {
	r.body = &body
	return r
}

func (r ApiPostEcommerceStoresIdCartsRequest) Execute() (*ECommerceCart, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdCartsExecute(r)
}

/*
PostEcommerceStoresIdCarts Add cart

Add a new cart to a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return ApiPostEcommerceStoresIdCartsRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdCarts(ctx context.Context, storeId string) ApiPostEcommerceStoresIdCartsRequest {
	return ApiPostEcommerceStoresIdCartsRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return ECommerceCart
func (a *EcommerceAPIService) PostEcommerceStoresIdCartsExecute(r ApiPostEcommerceStoresIdCartsRequest) (*ECommerceCart, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCart
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdCarts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEcommerceStoresIdCartsIdLinesRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	cartId string
	body *ECommerceCartLineItem1
}

func (r ApiPostEcommerceStoresIdCartsIdLinesRequest) Body(body ECommerceCartLineItem1) ApiPostEcommerceStoresIdCartsIdLinesRequest {
	r.body = &body
	return r
}

func (r ApiPostEcommerceStoresIdCartsIdLinesRequest) Execute() (*ECommerceCartLineItem, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdCartsIdLinesExecute(r)
}

/*
PostEcommerceStoresIdCartsIdLines Add cart line item

Add a new line item to an existing cart.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param cartId The id for the cart.
 @return ApiPostEcommerceStoresIdCartsIdLinesRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdCartsIdLines(ctx context.Context, storeId string, cartId string) ApiPostEcommerceStoresIdCartsIdLinesRequest {
	return ApiPostEcommerceStoresIdCartsIdLinesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		cartId: cartId,
	}
}

// Execute executes the request
//  @return ECommerceCartLineItem
func (a *EcommerceAPIService) PostEcommerceStoresIdCartsIdLinesExecute(r ApiPostEcommerceStoresIdCartsIdLinesRequest) (*ECommerceCartLineItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCartLineItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdCartsIdLines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts/{cart_id}/lines"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cart_id"+"}", url.PathEscape(parameterValueToString(r.cartId, "cartId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEcommerceStoresIdCustomersRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	body *ECommerceCustomer3
}

func (r ApiPostEcommerceStoresIdCustomersRequest) Body(body ECommerceCustomer3) ApiPostEcommerceStoresIdCustomersRequest {
	r.body = &body
	return r
}

func (r ApiPostEcommerceStoresIdCustomersRequest) Execute() (*ECommerceCustomer, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdCustomersExecute(r)
}

/*
PostEcommerceStoresIdCustomers Add customer

Add a new customer to a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return ApiPostEcommerceStoresIdCustomersRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdCustomers(ctx context.Context, storeId string) ApiPostEcommerceStoresIdCustomersRequest {
	return ApiPostEcommerceStoresIdCustomersRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return ECommerceCustomer
func (a *EcommerceAPIService) PostEcommerceStoresIdCustomersExecute(r ApiPostEcommerceStoresIdCustomersRequest) (*ECommerceCustomer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCustomer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdCustomers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/customers"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEcommerceStoresIdOrdersRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	body *ECommerceOrder1
}

func (r ApiPostEcommerceStoresIdOrdersRequest) Body(body ECommerceOrder1) ApiPostEcommerceStoresIdOrdersRequest {
	r.body = &body
	return r
}

func (r ApiPostEcommerceStoresIdOrdersRequest) Execute() (*ECommerceOrder, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdOrdersExecute(r)
}

/*
PostEcommerceStoresIdOrders Add order

Add a new order to a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return ApiPostEcommerceStoresIdOrdersRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdOrders(ctx context.Context, storeId string) ApiPostEcommerceStoresIdOrdersRequest {
	return ApiPostEcommerceStoresIdOrdersRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return ECommerceOrder
func (a *EcommerceAPIService) PostEcommerceStoresIdOrdersExecute(r ApiPostEcommerceStoresIdOrdersRequest) (*ECommerceOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdOrders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEcommerceStoresIdOrdersIdLinesRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	orderId string
	body *ECommerceOrderLineItem1
}

func (r ApiPostEcommerceStoresIdOrdersIdLinesRequest) Body(body ECommerceOrderLineItem1) ApiPostEcommerceStoresIdOrdersIdLinesRequest {
	r.body = &body
	return r
}

func (r ApiPostEcommerceStoresIdOrdersIdLinesRequest) Execute() (*ECommerceOrderLineItem, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdOrdersIdLinesExecute(r)
}

/*
PostEcommerceStoresIdOrdersIdLines Add order line item

Add a new line item to an existing order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param orderId The id for the order in a store.
 @return ApiPostEcommerceStoresIdOrdersIdLinesRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdOrdersIdLines(ctx context.Context, storeId string, orderId string) ApiPostEcommerceStoresIdOrdersIdLinesRequest {
	return ApiPostEcommerceStoresIdOrdersIdLinesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		orderId: orderId,
	}
}

// Execute executes the request
//  @return ECommerceOrderLineItem
func (a *EcommerceAPIService) PostEcommerceStoresIdOrdersIdLinesExecute(r ApiPostEcommerceStoresIdOrdersIdLinesRequest) (*ECommerceOrderLineItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceOrderLineItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdOrdersIdLines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders/{order_id}/lines"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEcommerceStoresIdProductsRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	body *ECommerceProduct1
}

func (r ApiPostEcommerceStoresIdProductsRequest) Body(body ECommerceProduct1) ApiPostEcommerceStoresIdProductsRequest {
	r.body = &body
	return r
}

func (r ApiPostEcommerceStoresIdProductsRequest) Execute() (*ECommerceProduct, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdProductsExecute(r)
}

/*
PostEcommerceStoresIdProducts Add product

Add a new product to a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return ApiPostEcommerceStoresIdProductsRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdProducts(ctx context.Context, storeId string) ApiPostEcommerceStoresIdProductsRequest {
	return ApiPostEcommerceStoresIdProductsRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return ECommerceProduct
func (a *EcommerceAPIService) PostEcommerceStoresIdProductsExecute(r ApiPostEcommerceStoresIdProductsRequest) (*ECommerceProduct, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProduct
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdProducts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEcommerceStoresIdProductsIdImagesRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	productId string
	body *ECommerceProductImage1
}

func (r ApiPostEcommerceStoresIdProductsIdImagesRequest) Body(body ECommerceProductImage1) ApiPostEcommerceStoresIdProductsIdImagesRequest {
	r.body = &body
	return r
}

func (r ApiPostEcommerceStoresIdProductsIdImagesRequest) Execute() (*ECommerceProductImage, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdProductsIdImagesExecute(r)
}

/*
PostEcommerceStoresIdProductsIdImages Add product image

Add a new image to the product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @return ApiPostEcommerceStoresIdProductsIdImagesRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdProductsIdImages(ctx context.Context, storeId string, productId string) ApiPostEcommerceStoresIdProductsIdImagesRequest {
	return ApiPostEcommerceStoresIdProductsIdImagesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
	}
}

// Execute executes the request
//  @return ECommerceProductImage
func (a *EcommerceAPIService) PostEcommerceStoresIdProductsIdImagesExecute(r ApiPostEcommerceStoresIdProductsIdImagesRequest) (*ECommerceProductImage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProductImage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdProductsIdImages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/images"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEcommerceStoresIdProductsIdVariantsRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	productId string
	body *ECommerceProductVariant1
}

func (r ApiPostEcommerceStoresIdProductsIdVariantsRequest) Body(body ECommerceProductVariant1) ApiPostEcommerceStoresIdProductsIdVariantsRequest {
	r.body = &body
	return r
}

func (r ApiPostEcommerceStoresIdProductsIdVariantsRequest) Execute() (*ECommerceProductVariant, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdProductsIdVariantsExecute(r)
}

/*
PostEcommerceStoresIdProductsIdVariants Add product variant

Add a new variant to the product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @return ApiPostEcommerceStoresIdProductsIdVariantsRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdProductsIdVariants(ctx context.Context, storeId string, productId string) ApiPostEcommerceStoresIdProductsIdVariantsRequest {
	return ApiPostEcommerceStoresIdProductsIdVariantsRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
	}
}

// Execute executes the request
//  @return ECommerceProductVariant
func (a *EcommerceAPIService) PostEcommerceStoresIdProductsIdVariantsExecute(r ApiPostEcommerceStoresIdProductsIdVariantsRequest) (*ECommerceProductVariant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProductVariant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdProductsIdVariants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/variants"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEcommerceStoresIdPromocodesRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	promoRuleId string
	body *ECommercePromoCode1
}

func (r ApiPostEcommerceStoresIdPromocodesRequest) Body(body ECommercePromoCode1) ApiPostEcommerceStoresIdPromocodesRequest {
	r.body = &body
	return r
}

func (r ApiPostEcommerceStoresIdPromocodesRequest) Execute() (*ECommercePromoCode, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdPromocodesExecute(r)
}

/*
PostEcommerceStoresIdPromocodes Add promo code

Add a new promo code to a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param promoRuleId The id for the promo rule of a store.
 @return ApiPostEcommerceStoresIdPromocodesRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdPromocodes(ctx context.Context, storeId string, promoRuleId string) ApiPostEcommerceStoresIdPromocodesRequest {
	return ApiPostEcommerceStoresIdPromocodesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		promoRuleId: promoRuleId,
	}
}

// Execute executes the request
//  @return ECommercePromoCode
func (a *EcommerceAPIService) PostEcommerceStoresIdPromocodesExecute(r ApiPostEcommerceStoresIdPromocodesRequest) (*ECommercePromoCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommercePromoCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdPromocodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules/{promo_rule_id}/promo-codes"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_rule_id"+"}", url.PathEscape(parameterValueToString(r.promoRuleId, "promoRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostEcommerceStoresIdPromorulesRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	body *ECommercePromoRule1
}

func (r ApiPostEcommerceStoresIdPromorulesRequest) Body(body ECommercePromoRule1) ApiPostEcommerceStoresIdPromorulesRequest {
	r.body = &body
	return r
}

func (r ApiPostEcommerceStoresIdPromorulesRequest) Execute() (*ECommercePromoRule, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdPromorulesExecute(r)
}

/*
PostEcommerceStoresIdPromorules Add promo rule

Add a new promo rule to a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return ApiPostEcommerceStoresIdPromorulesRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdPromorules(ctx context.Context, storeId string) ApiPostEcommerceStoresIdPromorulesRequest {
	return ApiPostEcommerceStoresIdPromorulesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return ECommercePromoRule
func (a *EcommerceAPIService) PostEcommerceStoresIdPromorulesExecute(r ApiPostEcommerceStoresIdPromorulesRequest) (*ECommercePromoRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommercePromoRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdPromorules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutEcommerceStoresIdCustomersIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	customerId string
	body *ECommerceCustomer4
}

func (r ApiPutEcommerceStoresIdCustomersIdRequest) Body(body ECommerceCustomer4) ApiPutEcommerceStoresIdCustomersIdRequest {
	r.body = &body
	return r
}

func (r ApiPutEcommerceStoresIdCustomersIdRequest) Execute() (*ECommerceCustomer, *http.Response, error) {
	return r.ApiService.PutEcommerceStoresIdCustomersIdExecute(r)
}

/*
PutEcommerceStoresIdCustomersId Add or update customer

Add or update a customer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param customerId The id for the customer of a store.
 @return ApiPutEcommerceStoresIdCustomersIdRequest
*/
func (a *EcommerceAPIService) PutEcommerceStoresIdCustomersId(ctx context.Context, storeId string, customerId string) ApiPutEcommerceStoresIdCustomersIdRequest {
	return ApiPutEcommerceStoresIdCustomersIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		customerId: customerId,
	}
}

// Execute executes the request
//  @return ECommerceCustomer
func (a *EcommerceAPIService) PutEcommerceStoresIdCustomersIdExecute(r ApiPutEcommerceStoresIdCustomersIdRequest) (*ECommerceCustomer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCustomer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PutEcommerceStoresIdCustomersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/customers/{customer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customer_id"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutEcommerceStoresIdProductsIdVariantsIdRequest struct {
	ctx context.Context
	ApiService *EcommerceAPIService
	storeId string
	productId string
	variantId string
	body *ECommerceProductVariant1
}

func (r ApiPutEcommerceStoresIdProductsIdVariantsIdRequest) Body(body ECommerceProductVariant1) ApiPutEcommerceStoresIdProductsIdVariantsIdRequest {
	r.body = &body
	return r
}

func (r ApiPutEcommerceStoresIdProductsIdVariantsIdRequest) Execute() (*ECommerceProductVariant, *http.Response, error) {
	return r.ApiService.PutEcommerceStoresIdProductsIdVariantsIdExecute(r)
}

/*
PutEcommerceStoresIdProductsIdVariantsId Add or update product variant

Add or update a product variant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @param variantId The id for the product variant.
 @return ApiPutEcommerceStoresIdProductsIdVariantsIdRequest
*/
func (a *EcommerceAPIService) PutEcommerceStoresIdProductsIdVariantsId(ctx context.Context, storeId string, productId string, variantId string) ApiPutEcommerceStoresIdProductsIdVariantsIdRequest {
	return ApiPutEcommerceStoresIdProductsIdVariantsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
		variantId: variantId,
	}
}

// Execute executes the request
//  @return ECommerceProductVariant
func (a *EcommerceAPIService) PutEcommerceStoresIdProductsIdVariantsIdExecute(r ApiPutEcommerceStoresIdProductsIdVariantsIdRequest) (*ECommerceProductVariant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProductVariant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PutEcommerceStoresIdProductsIdVariantsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/variants/{variant_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variant_id"+"}", url.PathEscape(parameterValueToString(r.variantId, "variantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
